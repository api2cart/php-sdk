<?php
/**
 * ProductApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * API2Cart OpenAPI
 *
 * API2Cart
 *
 * The version of the OpenAPI document: 1.1
 * Contact: contact@api2cart.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.11.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * ProductApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ProductApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'productAdd' => [
            'application/json',
        ],
        'productAddBatch' => [
            'application/json',
        ],
        'productAttributeList' => [
            'application/json',
        ],
        'productAttributeValueSet' => [
            'application/json',
        ],
        'productAttributeValueUnset' => [
            'application/json',
        ],
        'productBrandList' => [
            'application/json',
        ],
        'productChildItemFind' => [
            'application/json',
        ],
        'productChildItemInfo' => [
            'application/json',
        ],
        'productChildItemList' => [
            'application/json',
        ],
        'productCount' => [
            'application/json',
        ],
        'productCurrencyAdd' => [
            'application/json',
        ],
        'productCurrencyList' => [
            'application/json',
        ],
        'productDelete' => [
            'application/json',
        ],
        'productDeleteBatch' => [
            'application/json',
        ],
        'productFields' => [
            'application/json',
        ],
        'productFind' => [
            'application/json',
        ],
        'productImageAdd' => [
            'application/json',
        ],
        'productImageDelete' => [
            'application/json',
        ],
        'productImageUpdate' => [
            'application/json',
        ],
        'productInfo' => [
            'application/json',
        ],
        'productList' => [
            'application/json',
        ],
        'productManufacturerAdd' => [
            'application/json',
        ],
        'productOptionAdd' => [
            'application/json',
        ],
        'productOptionAssign' => [
            'application/json',
        ],
        'productOptionDelete' => [
            'application/json',
        ],
        'productOptionList' => [
            'application/json',
        ],
        'productOptionValueAdd' => [
            'application/json',
        ],
        'productOptionValueAssign' => [
            'application/json',
        ],
        'productOptionValueDelete' => [
            'application/json',
        ],
        'productOptionValueUpdate' => [
            'application/json',
        ],
        'productPriceAdd' => [
            'application/json',
        ],
        'productPriceDelete' => [
            'application/json',
        ],
        'productPriceUpdate' => [
            'application/json',
        ],
        'productReviewList' => [
            'application/json',
        ],
        'productStoreAssign' => [
            'application/json',
        ],
        'productTaxAdd' => [
            'application/json',
        ],
        'productUpdate' => [
            'application/json',
        ],
        'productUpdateBatch' => [
            'application/json',
        ],
        'productVariantAdd' => [
            'application/json',
        ],
        'productVariantAddBatch' => [
            'application/json',
        ],
        'productVariantCount' => [
            'application/json',
        ],
        'productVariantDelete' => [
            'application/json',
        ],
        'productVariantDeleteBatch' => [
            'application/json',
        ],
        'productVariantImageAdd' => [
            'application/json',
        ],
        'productVariantImageDelete' => [
            'application/json',
        ],
        'productVariantInfo' => [
            'application/json',
        ],
        'productVariantList' => [
            'application/json',
        ],
        'productVariantPriceAdd' => [
            'application/json',
        ],
        'productVariantPriceDelete' => [
            'application/json',
        ],
        'productVariantPriceUpdate' => [
            'application/json',
        ],
        'productVariantUpdate' => [
            'application/json',
        ],
        'productVariantUpdateBatch' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation productAdd
     *
     * product.add
     *
     * @param  \OpenAPI\Client\Model\ProductAdd $product_add product_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productAdd'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductAdd200Response
     */
    public function productAdd($product_add, string $contentType = self::contentTypes['productAdd'][0])
    {
        list($response) = $this->productAddWithHttpInfo($product_add, $contentType);
        return $response;
    }

    /**
     * Operation productAddWithHttpInfo
     *
     * product.add
     *
     * @param  \OpenAPI\Client\Model\ProductAdd $product_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productAdd'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductAdd200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productAddWithHttpInfo($product_add, string $contentType = self::contentTypes['productAdd'][0])
    {
        $request = $this->productAddRequest($product_add, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProductAdd200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProductAdd200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProductAdd200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ProductAdd200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductAdd200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productAddAsync
     *
     * product.add
     *
     * @param  \OpenAPI\Client\Model\ProductAdd $product_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productAddAsync($product_add, string $contentType = self::contentTypes['productAdd'][0])
    {
        return $this->productAddAsyncWithHttpInfo($product_add, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productAddAsyncWithHttpInfo
     *
     * product.add
     *
     * @param  \OpenAPI\Client\Model\ProductAdd $product_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productAddAsyncWithHttpInfo($product_add, string $contentType = self::contentTypes['productAdd'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProductAdd200Response';
        $request = $this->productAddRequest($product_add, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productAdd'
     *
     * @param  \OpenAPI\Client\Model\ProductAdd $product_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productAddRequest($product_add, string $contentType = self::contentTypes['productAdd'][0])
    {

        // verify the required parameter 'product_add' is set
        if ($product_add === null || (is_array($product_add) && count($product_add) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_add when calling productAdd'
            );
        }


        $resourcePath = '/product.add.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($product_add)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($product_add));
            } else {
                $httpBody = $product_add;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productAddBatch
     *
     * product.add.batch
     *
     * @param  \OpenAPI\Client\Model\ProductAddBatch $product_add_batch product_add_batch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productAddBatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CategoryAddBatch200Response
     */
    public function productAddBatch($product_add_batch, string $contentType = self::contentTypes['productAddBatch'][0])
    {
        list($response) = $this->productAddBatchWithHttpInfo($product_add_batch, $contentType);
        return $response;
    }

    /**
     * Operation productAddBatchWithHttpInfo
     *
     * product.add.batch
     *
     * @param  \OpenAPI\Client\Model\ProductAddBatch $product_add_batch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productAddBatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CategoryAddBatch200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productAddBatchWithHttpInfo($product_add_batch, string $contentType = self::contentTypes['productAddBatch'][0])
    {
        $request = $this->productAddBatchRequest($product_add_batch, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CategoryAddBatch200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CategoryAddBatch200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CategoryAddBatch200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\CategoryAddBatch200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CategoryAddBatch200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productAddBatchAsync
     *
     * product.add.batch
     *
     * @param  \OpenAPI\Client\Model\ProductAddBatch $product_add_batch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productAddBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productAddBatchAsync($product_add_batch, string $contentType = self::contentTypes['productAddBatch'][0])
    {
        return $this->productAddBatchAsyncWithHttpInfo($product_add_batch, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productAddBatchAsyncWithHttpInfo
     *
     * product.add.batch
     *
     * @param  \OpenAPI\Client\Model\ProductAddBatch $product_add_batch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productAddBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productAddBatchAsyncWithHttpInfo($product_add_batch, string $contentType = self::contentTypes['productAddBatch'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CategoryAddBatch200Response';
        $request = $this->productAddBatchRequest($product_add_batch, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productAddBatch'
     *
     * @param  \OpenAPI\Client\Model\ProductAddBatch $product_add_batch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productAddBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productAddBatchRequest($product_add_batch, string $contentType = self::contentTypes['productAddBatch'][0])
    {

        // verify the required parameter 'product_add_batch' is set
        if ($product_add_batch === null || (is_array($product_add_batch) && count($product_add_batch) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_add_batch when calling productAddBatch'
            );
        }


        $resourcePath = '/product.add.batch.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($product_add_batch)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($product_add_batch));
            } else {
                $httpBody = $product_add_batch;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productAttributeList
     *
     * product.attribute.list
     *
     * @param  string $product_id Retrieves attributes specified by product id (required)
     * @param  string|null $attribute_id Retrieves info for specified attribute_id (optional)
     * @param  string|null $variant_id Defines product&#39;s variants specified by variant id (optional)
     * @param  string|null $page_cursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $attribute_group_id Filter by attribute_group_id (optional)
     * @param  string|null $set_name Retrieves attributes specified by set_name in Magento (optional)
     * @param  string|null $lang_id Retrieves attributes specified by language id (optional)
     * @param  string|null $store_id Retrieves attributes specified by store id (optional)
     * @param  string|null $sort_by Set field to sort by (optional, default to 'attribute_id')
     * @param  string|null $sort_direction Set sorting direction (optional, default to 'asc')
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'attribute_id,name')
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productAttributeList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModelResponseProductAttributeList
     */
    public function productAttributeList($product_id, $attribute_id = null, $variant_id = null, $page_cursor = null, $start = 0, $count = 10, $attribute_group_id = null, $set_name = null, $lang_id = null, $store_id = null, $sort_by = 'attribute_id', $sort_direction = 'asc', $params = 'attribute_id,name', $response_fields = null, $exclude = null, string $contentType = self::contentTypes['productAttributeList'][0])
    {
        list($response) = $this->productAttributeListWithHttpInfo($product_id, $attribute_id, $variant_id, $page_cursor, $start, $count, $attribute_group_id, $set_name, $lang_id, $store_id, $sort_by, $sort_direction, $params, $response_fields, $exclude, $contentType);
        return $response;
    }

    /**
     * Operation productAttributeListWithHttpInfo
     *
     * product.attribute.list
     *
     * @param  string $product_id Retrieves attributes specified by product id (required)
     * @param  string|null $attribute_id Retrieves info for specified attribute_id (optional)
     * @param  string|null $variant_id Defines product&#39;s variants specified by variant id (optional)
     * @param  string|null $page_cursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $attribute_group_id Filter by attribute_group_id (optional)
     * @param  string|null $set_name Retrieves attributes specified by set_name in Magento (optional)
     * @param  string|null $lang_id Retrieves attributes specified by language id (optional)
     * @param  string|null $store_id Retrieves attributes specified by store id (optional)
     * @param  string|null $sort_by Set field to sort by (optional, default to 'attribute_id')
     * @param  string|null $sort_direction Set sorting direction (optional, default to 'asc')
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'attribute_id,name')
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productAttributeList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModelResponseProductAttributeList, HTTP status code, HTTP response headers (array of strings)
     */
    public function productAttributeListWithHttpInfo($product_id, $attribute_id = null, $variant_id = null, $page_cursor = null, $start = 0, $count = 10, $attribute_group_id = null, $set_name = null, $lang_id = null, $store_id = null, $sort_by = 'attribute_id', $sort_direction = 'asc', $params = 'attribute_id,name', $response_fields = null, $exclude = null, string $contentType = self::contentTypes['productAttributeList'][0])
    {
        $request = $this->productAttributeListRequest($product_id, $attribute_id, $variant_id, $page_cursor, $start, $count, $attribute_group_id, $set_name, $lang_id, $store_id, $sort_by, $sort_direction, $params, $response_fields, $exclude, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModelResponseProductAttributeList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ModelResponseProductAttributeList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModelResponseProductAttributeList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ModelResponseProductAttributeList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModelResponseProductAttributeList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productAttributeListAsync
     *
     * product.attribute.list
     *
     * @param  string $product_id Retrieves attributes specified by product id (required)
     * @param  string|null $attribute_id Retrieves info for specified attribute_id (optional)
     * @param  string|null $variant_id Defines product&#39;s variants specified by variant id (optional)
     * @param  string|null $page_cursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $attribute_group_id Filter by attribute_group_id (optional)
     * @param  string|null $set_name Retrieves attributes specified by set_name in Magento (optional)
     * @param  string|null $lang_id Retrieves attributes specified by language id (optional)
     * @param  string|null $store_id Retrieves attributes specified by store id (optional)
     * @param  string|null $sort_by Set field to sort by (optional, default to 'attribute_id')
     * @param  string|null $sort_direction Set sorting direction (optional, default to 'asc')
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'attribute_id,name')
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productAttributeList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productAttributeListAsync($product_id, $attribute_id = null, $variant_id = null, $page_cursor = null, $start = 0, $count = 10, $attribute_group_id = null, $set_name = null, $lang_id = null, $store_id = null, $sort_by = 'attribute_id', $sort_direction = 'asc', $params = 'attribute_id,name', $response_fields = null, $exclude = null, string $contentType = self::contentTypes['productAttributeList'][0])
    {
        return $this->productAttributeListAsyncWithHttpInfo($product_id, $attribute_id, $variant_id, $page_cursor, $start, $count, $attribute_group_id, $set_name, $lang_id, $store_id, $sort_by, $sort_direction, $params, $response_fields, $exclude, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productAttributeListAsyncWithHttpInfo
     *
     * product.attribute.list
     *
     * @param  string $product_id Retrieves attributes specified by product id (required)
     * @param  string|null $attribute_id Retrieves info for specified attribute_id (optional)
     * @param  string|null $variant_id Defines product&#39;s variants specified by variant id (optional)
     * @param  string|null $page_cursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $attribute_group_id Filter by attribute_group_id (optional)
     * @param  string|null $set_name Retrieves attributes specified by set_name in Magento (optional)
     * @param  string|null $lang_id Retrieves attributes specified by language id (optional)
     * @param  string|null $store_id Retrieves attributes specified by store id (optional)
     * @param  string|null $sort_by Set field to sort by (optional, default to 'attribute_id')
     * @param  string|null $sort_direction Set sorting direction (optional, default to 'asc')
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'attribute_id,name')
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productAttributeList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productAttributeListAsyncWithHttpInfo($product_id, $attribute_id = null, $variant_id = null, $page_cursor = null, $start = 0, $count = 10, $attribute_group_id = null, $set_name = null, $lang_id = null, $store_id = null, $sort_by = 'attribute_id', $sort_direction = 'asc', $params = 'attribute_id,name', $response_fields = null, $exclude = null, string $contentType = self::contentTypes['productAttributeList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ModelResponseProductAttributeList';
        $request = $this->productAttributeListRequest($product_id, $attribute_id, $variant_id, $page_cursor, $start, $count, $attribute_group_id, $set_name, $lang_id, $store_id, $sort_by, $sort_direction, $params, $response_fields, $exclude, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productAttributeList'
     *
     * @param  string $product_id Retrieves attributes specified by product id (required)
     * @param  string|null $attribute_id Retrieves info for specified attribute_id (optional)
     * @param  string|null $variant_id Defines product&#39;s variants specified by variant id (optional)
     * @param  string|null $page_cursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $attribute_group_id Filter by attribute_group_id (optional)
     * @param  string|null $set_name Retrieves attributes specified by set_name in Magento (optional)
     * @param  string|null $lang_id Retrieves attributes specified by language id (optional)
     * @param  string|null $store_id Retrieves attributes specified by store id (optional)
     * @param  string|null $sort_by Set field to sort by (optional, default to 'attribute_id')
     * @param  string|null $sort_direction Set sorting direction (optional, default to 'asc')
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'attribute_id,name')
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productAttributeList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productAttributeListRequest($product_id, $attribute_id = null, $variant_id = null, $page_cursor = null, $start = 0, $count = 10, $attribute_group_id = null, $set_name = null, $lang_id = null, $store_id = null, $sort_by = 'attribute_id', $sort_direction = 'asc', $params = 'attribute_id,name', $response_fields = null, $exclude = null, string $contentType = self::contentTypes['productAttributeList'][0])
    {

        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_id when calling productAttributeList'
            );
        }
















        $resourcePath = '/product.attribute.list.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_id,
            'product_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $attribute_id,
            'attribute_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $variant_id,
            'variant_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_cursor,
            'page_cursor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $attribute_group_id,
            'attribute_group_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $set_name,
            'set_name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lang_id,
            'lang_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $store_id,
            'store_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_by,
            'sort_by', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_direction,
            'sort_direction', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $params,
            'params', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $response_fields,
            'response_fields', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclude,
            'exclude', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productAttributeValueSet
     *
     * product.attribute.value.set
     *
     * @param  string $product_id Defines product id where the attribute should be added (required)
     * @param  string|null $attribute_id Filter by attribute_id (optional)
     * @param  string|null $attribute_group_id Filter by attribute_group_id (optional)
     * @param  string|null $attribute_name Define attribute name (optional)
     * @param  string|null $value Define attribute value (optional)
     * @param  int|null $value_id Define attribute value id (optional)
     * @param  string|null $lang_id Language id (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productAttributeValueSet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductAttributeValueSet200Response
     */
    public function productAttributeValueSet($product_id, $attribute_id = null, $attribute_group_id = null, $attribute_name = null, $value = null, $value_id = null, $lang_id = null, $store_id = null, string $contentType = self::contentTypes['productAttributeValueSet'][0])
    {
        list($response) = $this->productAttributeValueSetWithHttpInfo($product_id, $attribute_id, $attribute_group_id, $attribute_name, $value, $value_id, $lang_id, $store_id, $contentType);
        return $response;
    }

    /**
     * Operation productAttributeValueSetWithHttpInfo
     *
     * product.attribute.value.set
     *
     * @param  string $product_id Defines product id where the attribute should be added (required)
     * @param  string|null $attribute_id Filter by attribute_id (optional)
     * @param  string|null $attribute_group_id Filter by attribute_group_id (optional)
     * @param  string|null $attribute_name Define attribute name (optional)
     * @param  string|null $value Define attribute value (optional)
     * @param  int|null $value_id Define attribute value id (optional)
     * @param  string|null $lang_id Language id (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productAttributeValueSet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductAttributeValueSet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productAttributeValueSetWithHttpInfo($product_id, $attribute_id = null, $attribute_group_id = null, $attribute_name = null, $value = null, $value_id = null, $lang_id = null, $store_id = null, string $contentType = self::contentTypes['productAttributeValueSet'][0])
    {
        $request = $this->productAttributeValueSetRequest($product_id, $attribute_id, $attribute_group_id, $attribute_name, $value, $value_id, $lang_id, $store_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProductAttributeValueSet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProductAttributeValueSet200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProductAttributeValueSet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ProductAttributeValueSet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductAttributeValueSet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productAttributeValueSetAsync
     *
     * product.attribute.value.set
     *
     * @param  string $product_id Defines product id where the attribute should be added (required)
     * @param  string|null $attribute_id Filter by attribute_id (optional)
     * @param  string|null $attribute_group_id Filter by attribute_group_id (optional)
     * @param  string|null $attribute_name Define attribute name (optional)
     * @param  string|null $value Define attribute value (optional)
     * @param  int|null $value_id Define attribute value id (optional)
     * @param  string|null $lang_id Language id (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productAttributeValueSet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productAttributeValueSetAsync($product_id, $attribute_id = null, $attribute_group_id = null, $attribute_name = null, $value = null, $value_id = null, $lang_id = null, $store_id = null, string $contentType = self::contentTypes['productAttributeValueSet'][0])
    {
        return $this->productAttributeValueSetAsyncWithHttpInfo($product_id, $attribute_id, $attribute_group_id, $attribute_name, $value, $value_id, $lang_id, $store_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productAttributeValueSetAsyncWithHttpInfo
     *
     * product.attribute.value.set
     *
     * @param  string $product_id Defines product id where the attribute should be added (required)
     * @param  string|null $attribute_id Filter by attribute_id (optional)
     * @param  string|null $attribute_group_id Filter by attribute_group_id (optional)
     * @param  string|null $attribute_name Define attribute name (optional)
     * @param  string|null $value Define attribute value (optional)
     * @param  int|null $value_id Define attribute value id (optional)
     * @param  string|null $lang_id Language id (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productAttributeValueSet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productAttributeValueSetAsyncWithHttpInfo($product_id, $attribute_id = null, $attribute_group_id = null, $attribute_name = null, $value = null, $value_id = null, $lang_id = null, $store_id = null, string $contentType = self::contentTypes['productAttributeValueSet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProductAttributeValueSet200Response';
        $request = $this->productAttributeValueSetRequest($product_id, $attribute_id, $attribute_group_id, $attribute_name, $value, $value_id, $lang_id, $store_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productAttributeValueSet'
     *
     * @param  string $product_id Defines product id where the attribute should be added (required)
     * @param  string|null $attribute_id Filter by attribute_id (optional)
     * @param  string|null $attribute_group_id Filter by attribute_group_id (optional)
     * @param  string|null $attribute_name Define attribute name (optional)
     * @param  string|null $value Define attribute value (optional)
     * @param  int|null $value_id Define attribute value id (optional)
     * @param  string|null $lang_id Language id (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productAttributeValueSet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productAttributeValueSetRequest($product_id, $attribute_id = null, $attribute_group_id = null, $attribute_name = null, $value = null, $value_id = null, $lang_id = null, $store_id = null, string $contentType = self::contentTypes['productAttributeValueSet'][0])
    {

        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_id when calling productAttributeValueSet'
            );
        }









        $resourcePath = '/product.attribute.value.set.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_id,
            'product_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $attribute_id,
            'attribute_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $attribute_group_id,
            'attribute_group_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $attribute_name,
            'attribute_name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $value,
            'value', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $value_id,
            'value_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lang_id,
            'lang_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $store_id,
            'store_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productAttributeValueUnset
     *
     * product.attribute.value.unset
     *
     * @param  string $product_id Product id (required)
     * @param  string $attribute_id Attribute Id (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  bool|null $include_default Boolean, whether or not to unset default value of the attribute, if applicable (optional, default to false)
     * @param  bool|null $reindex Is reindex required (optional, default to true)
     * @param  bool|null $clear_cache Is cache clear required (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productAttributeValueUnset'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductAttributeValueUnset200Response
     */
    public function productAttributeValueUnset($product_id, $attribute_id, $store_id = null, $include_default = false, $reindex = true, $clear_cache = true, string $contentType = self::contentTypes['productAttributeValueUnset'][0])
    {
        list($response) = $this->productAttributeValueUnsetWithHttpInfo($product_id, $attribute_id, $store_id, $include_default, $reindex, $clear_cache, $contentType);
        return $response;
    }

    /**
     * Operation productAttributeValueUnsetWithHttpInfo
     *
     * product.attribute.value.unset
     *
     * @param  string $product_id Product id (required)
     * @param  string $attribute_id Attribute Id (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  bool|null $include_default Boolean, whether or not to unset default value of the attribute, if applicable (optional, default to false)
     * @param  bool|null $reindex Is reindex required (optional, default to true)
     * @param  bool|null $clear_cache Is cache clear required (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productAttributeValueUnset'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductAttributeValueUnset200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productAttributeValueUnsetWithHttpInfo($product_id, $attribute_id, $store_id = null, $include_default = false, $reindex = true, $clear_cache = true, string $contentType = self::contentTypes['productAttributeValueUnset'][0])
    {
        $request = $this->productAttributeValueUnsetRequest($product_id, $attribute_id, $store_id, $include_default, $reindex, $clear_cache, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProductAttributeValueUnset200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProductAttributeValueUnset200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProductAttributeValueUnset200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ProductAttributeValueUnset200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductAttributeValueUnset200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productAttributeValueUnsetAsync
     *
     * product.attribute.value.unset
     *
     * @param  string $product_id Product id (required)
     * @param  string $attribute_id Attribute Id (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  bool|null $include_default Boolean, whether or not to unset default value of the attribute, if applicable (optional, default to false)
     * @param  bool|null $reindex Is reindex required (optional, default to true)
     * @param  bool|null $clear_cache Is cache clear required (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productAttributeValueUnset'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productAttributeValueUnsetAsync($product_id, $attribute_id, $store_id = null, $include_default = false, $reindex = true, $clear_cache = true, string $contentType = self::contentTypes['productAttributeValueUnset'][0])
    {
        return $this->productAttributeValueUnsetAsyncWithHttpInfo($product_id, $attribute_id, $store_id, $include_default, $reindex, $clear_cache, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productAttributeValueUnsetAsyncWithHttpInfo
     *
     * product.attribute.value.unset
     *
     * @param  string $product_id Product id (required)
     * @param  string $attribute_id Attribute Id (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  bool|null $include_default Boolean, whether or not to unset default value of the attribute, if applicable (optional, default to false)
     * @param  bool|null $reindex Is reindex required (optional, default to true)
     * @param  bool|null $clear_cache Is cache clear required (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productAttributeValueUnset'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productAttributeValueUnsetAsyncWithHttpInfo($product_id, $attribute_id, $store_id = null, $include_default = false, $reindex = true, $clear_cache = true, string $contentType = self::contentTypes['productAttributeValueUnset'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProductAttributeValueUnset200Response';
        $request = $this->productAttributeValueUnsetRequest($product_id, $attribute_id, $store_id, $include_default, $reindex, $clear_cache, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productAttributeValueUnset'
     *
     * @param  string $product_id Product id (required)
     * @param  string $attribute_id Attribute Id (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  bool|null $include_default Boolean, whether or not to unset default value of the attribute, if applicable (optional, default to false)
     * @param  bool|null $reindex Is reindex required (optional, default to true)
     * @param  bool|null $clear_cache Is cache clear required (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productAttributeValueUnset'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productAttributeValueUnsetRequest($product_id, $attribute_id, $store_id = null, $include_default = false, $reindex = true, $clear_cache = true, string $contentType = self::contentTypes['productAttributeValueUnset'][0])
    {

        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_id when calling productAttributeValueUnset'
            );
        }

        // verify the required parameter 'attribute_id' is set
        if ($attribute_id === null || (is_array($attribute_id) && count($attribute_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attribute_id when calling productAttributeValueUnset'
            );
        }






        $resourcePath = '/product.attribute.value.unset.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_id,
            'product_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $attribute_id,
            'attribute_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $store_id,
            'store_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_default,
            'include_default', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $reindex,
            'reindex', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $clear_cache,
            'clear_cache', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productBrandList
     *
     * product.brand.list
     *
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $page_cursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,name,short_description,active,url')
     * @param  string|null $brand_ids Retrieves brands specified by brand ids (optional)
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string|null $lang_id Language id (optional)
     * @param  string|null $created_from Retrieve entities from their creation date (optional)
     * @param  string|null $created_to Retrieve entities to their creation date (optional)
     * @param  string|null $modified_from Retrieve entities from their modification date (optional)
     * @param  string|null $modified_to Retrieve entities to their modification date (optional)
     * @param  string|null $parent_id Retrieves brands specified by parent id (optional)
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string|null $find_where Entity search that is specified by the comma-separated unique fields (optional)
     * @param  string|null $find_value Entity search that is specified by some value (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productBrandList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModelResponseProductBrandList
     */
    public function productBrandList($start = 0, $count = 10, $page_cursor = null, $params = 'id,name,short_description,active,url', $brand_ids = null, $exclude = null, $store_id = null, $lang_id = null, $created_from = null, $created_to = null, $modified_from = null, $modified_to = null, $parent_id = null, $response_fields = null, $find_where = null, $find_value = null, string $contentType = self::contentTypes['productBrandList'][0])
    {
        list($response) = $this->productBrandListWithHttpInfo($start, $count, $page_cursor, $params, $brand_ids, $exclude, $store_id, $lang_id, $created_from, $created_to, $modified_from, $modified_to, $parent_id, $response_fields, $find_where, $find_value, $contentType);
        return $response;
    }

    /**
     * Operation productBrandListWithHttpInfo
     *
     * product.brand.list
     *
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $page_cursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,name,short_description,active,url')
     * @param  string|null $brand_ids Retrieves brands specified by brand ids (optional)
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string|null $lang_id Language id (optional)
     * @param  string|null $created_from Retrieve entities from their creation date (optional)
     * @param  string|null $created_to Retrieve entities to their creation date (optional)
     * @param  string|null $modified_from Retrieve entities from their modification date (optional)
     * @param  string|null $modified_to Retrieve entities to their modification date (optional)
     * @param  string|null $parent_id Retrieves brands specified by parent id (optional)
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string|null $find_where Entity search that is specified by the comma-separated unique fields (optional)
     * @param  string|null $find_value Entity search that is specified by some value (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productBrandList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModelResponseProductBrandList, HTTP status code, HTTP response headers (array of strings)
     */
    public function productBrandListWithHttpInfo($start = 0, $count = 10, $page_cursor = null, $params = 'id,name,short_description,active,url', $brand_ids = null, $exclude = null, $store_id = null, $lang_id = null, $created_from = null, $created_to = null, $modified_from = null, $modified_to = null, $parent_id = null, $response_fields = null, $find_where = null, $find_value = null, string $contentType = self::contentTypes['productBrandList'][0])
    {
        $request = $this->productBrandListRequest($start, $count, $page_cursor, $params, $brand_ids, $exclude, $store_id, $lang_id, $created_from, $created_to, $modified_from, $modified_to, $parent_id, $response_fields, $find_where, $find_value, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModelResponseProductBrandList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ModelResponseProductBrandList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModelResponseProductBrandList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ModelResponseProductBrandList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModelResponseProductBrandList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productBrandListAsync
     *
     * product.brand.list
     *
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $page_cursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,name,short_description,active,url')
     * @param  string|null $brand_ids Retrieves brands specified by brand ids (optional)
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string|null $lang_id Language id (optional)
     * @param  string|null $created_from Retrieve entities from their creation date (optional)
     * @param  string|null $created_to Retrieve entities to their creation date (optional)
     * @param  string|null $modified_from Retrieve entities from their modification date (optional)
     * @param  string|null $modified_to Retrieve entities to their modification date (optional)
     * @param  string|null $parent_id Retrieves brands specified by parent id (optional)
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string|null $find_where Entity search that is specified by the comma-separated unique fields (optional)
     * @param  string|null $find_value Entity search that is specified by some value (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productBrandList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productBrandListAsync($start = 0, $count = 10, $page_cursor = null, $params = 'id,name,short_description,active,url', $brand_ids = null, $exclude = null, $store_id = null, $lang_id = null, $created_from = null, $created_to = null, $modified_from = null, $modified_to = null, $parent_id = null, $response_fields = null, $find_where = null, $find_value = null, string $contentType = self::contentTypes['productBrandList'][0])
    {
        return $this->productBrandListAsyncWithHttpInfo($start, $count, $page_cursor, $params, $brand_ids, $exclude, $store_id, $lang_id, $created_from, $created_to, $modified_from, $modified_to, $parent_id, $response_fields, $find_where, $find_value, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productBrandListAsyncWithHttpInfo
     *
     * product.brand.list
     *
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $page_cursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,name,short_description,active,url')
     * @param  string|null $brand_ids Retrieves brands specified by brand ids (optional)
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string|null $lang_id Language id (optional)
     * @param  string|null $created_from Retrieve entities from their creation date (optional)
     * @param  string|null $created_to Retrieve entities to their creation date (optional)
     * @param  string|null $modified_from Retrieve entities from their modification date (optional)
     * @param  string|null $modified_to Retrieve entities to their modification date (optional)
     * @param  string|null $parent_id Retrieves brands specified by parent id (optional)
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string|null $find_where Entity search that is specified by the comma-separated unique fields (optional)
     * @param  string|null $find_value Entity search that is specified by some value (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productBrandList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productBrandListAsyncWithHttpInfo($start = 0, $count = 10, $page_cursor = null, $params = 'id,name,short_description,active,url', $brand_ids = null, $exclude = null, $store_id = null, $lang_id = null, $created_from = null, $created_to = null, $modified_from = null, $modified_to = null, $parent_id = null, $response_fields = null, $find_where = null, $find_value = null, string $contentType = self::contentTypes['productBrandList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ModelResponseProductBrandList';
        $request = $this->productBrandListRequest($start, $count, $page_cursor, $params, $brand_ids, $exclude, $store_id, $lang_id, $created_from, $created_to, $modified_from, $modified_to, $parent_id, $response_fields, $find_where, $find_value, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productBrandList'
     *
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $page_cursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,name,short_description,active,url')
     * @param  string|null $brand_ids Retrieves brands specified by brand ids (optional)
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string|null $lang_id Language id (optional)
     * @param  string|null $created_from Retrieve entities from their creation date (optional)
     * @param  string|null $created_to Retrieve entities to their creation date (optional)
     * @param  string|null $modified_from Retrieve entities from their modification date (optional)
     * @param  string|null $modified_to Retrieve entities to their modification date (optional)
     * @param  string|null $parent_id Retrieves brands specified by parent id (optional)
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string|null $find_where Entity search that is specified by the comma-separated unique fields (optional)
     * @param  string|null $find_value Entity search that is specified by some value (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productBrandList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productBrandListRequest($start = 0, $count = 10, $page_cursor = null, $params = 'id,name,short_description,active,url', $brand_ids = null, $exclude = null, $store_id = null, $lang_id = null, $created_from = null, $created_to = null, $modified_from = null, $modified_to = null, $parent_id = null, $response_fields = null, $find_where = null, $find_value = null, string $contentType = self::contentTypes['productBrandList'][0])
    {


















        $resourcePath = '/product.brand.list.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_cursor,
            'page_cursor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $params,
            'params', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $brand_ids,
            'brand_ids', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclude,
            'exclude', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $store_id,
            'store_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lang_id,
            'lang_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_from,
            'created_from', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_to,
            'created_to', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_from,
            'modified_from', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_to,
            'modified_to', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parent_id,
            'parent_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $response_fields,
            'response_fields', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $find_where,
            'find_where', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $find_value,
            'find_value', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productChildItemFind
     *
     * product.child_item.find
     *
     * @param  string|null $find_value Entity search that is specified by some value (optional)
     * @param  string|null $find_where Entity search that is specified by the comma-separated unique fields (optional)
     * @param  string|null $find_params Entity search that is specified by comma-separated parameters (optional, default to 'whole_words')
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productChildItemFind'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductChildItemFind200Response
     */
    public function productChildItemFind($find_value = null, $find_where = null, $find_params = 'whole_words', $store_id = null, string $contentType = self::contentTypes['productChildItemFind'][0])
    {
        list($response) = $this->productChildItemFindWithHttpInfo($find_value, $find_where, $find_params, $store_id, $contentType);
        return $response;
    }

    /**
     * Operation productChildItemFindWithHttpInfo
     *
     * product.child_item.find
     *
     * @param  string|null $find_value Entity search that is specified by some value (optional)
     * @param  string|null $find_where Entity search that is specified by the comma-separated unique fields (optional)
     * @param  string|null $find_params Entity search that is specified by comma-separated parameters (optional, default to 'whole_words')
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productChildItemFind'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductChildItemFind200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productChildItemFindWithHttpInfo($find_value = null, $find_where = null, $find_params = 'whole_words', $store_id = null, string $contentType = self::contentTypes['productChildItemFind'][0])
    {
        $request = $this->productChildItemFindRequest($find_value, $find_where, $find_params, $store_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProductChildItemFind200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProductChildItemFind200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProductChildItemFind200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ProductChildItemFind200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductChildItemFind200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productChildItemFindAsync
     *
     * product.child_item.find
     *
     * @param  string|null $find_value Entity search that is specified by some value (optional)
     * @param  string|null $find_where Entity search that is specified by the comma-separated unique fields (optional)
     * @param  string|null $find_params Entity search that is specified by comma-separated parameters (optional, default to 'whole_words')
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productChildItemFind'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productChildItemFindAsync($find_value = null, $find_where = null, $find_params = 'whole_words', $store_id = null, string $contentType = self::contentTypes['productChildItemFind'][0])
    {
        return $this->productChildItemFindAsyncWithHttpInfo($find_value, $find_where, $find_params, $store_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productChildItemFindAsyncWithHttpInfo
     *
     * product.child_item.find
     *
     * @param  string|null $find_value Entity search that is specified by some value (optional)
     * @param  string|null $find_where Entity search that is specified by the comma-separated unique fields (optional)
     * @param  string|null $find_params Entity search that is specified by comma-separated parameters (optional, default to 'whole_words')
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productChildItemFind'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productChildItemFindAsyncWithHttpInfo($find_value = null, $find_where = null, $find_params = 'whole_words', $store_id = null, string $contentType = self::contentTypes['productChildItemFind'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProductChildItemFind200Response';
        $request = $this->productChildItemFindRequest($find_value, $find_where, $find_params, $store_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productChildItemFind'
     *
     * @param  string|null $find_value Entity search that is specified by some value (optional)
     * @param  string|null $find_where Entity search that is specified by the comma-separated unique fields (optional)
     * @param  string|null $find_params Entity search that is specified by comma-separated parameters (optional, default to 'whole_words')
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productChildItemFind'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productChildItemFindRequest($find_value = null, $find_where = null, $find_params = 'whole_words', $store_id = null, string $contentType = self::contentTypes['productChildItemFind'][0])
    {






        $resourcePath = '/product.child_item.find.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $find_value,
            'find_value', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $find_where,
            'find_where', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $find_params,
            'find_params', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $store_id,
            'store_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productChildItemInfo
     *
     * product.child_item.info
     *
     * @param  string $product_id Filter by parent product id (required)
     * @param  string $id Entity id (required)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'force_all')
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string|null $lang_id Language id (optional)
     * @param  string|null $currency_id Currency Id (optional)
     * @param  bool|null $use_latest_api_version Use the latest platform API version (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productChildItemInfo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductChildItemInfo200Response
     */
    public function productChildItemInfo($product_id, $id, $params = 'force_all', $response_fields = null, $exclude = null, $store_id = null, $lang_id = null, $currency_id = null, $use_latest_api_version = false, string $contentType = self::contentTypes['productChildItemInfo'][0])
    {
        list($response) = $this->productChildItemInfoWithHttpInfo($product_id, $id, $params, $response_fields, $exclude, $store_id, $lang_id, $currency_id, $use_latest_api_version, $contentType);
        return $response;
    }

    /**
     * Operation productChildItemInfoWithHttpInfo
     *
     * product.child_item.info
     *
     * @param  string $product_id Filter by parent product id (required)
     * @param  string $id Entity id (required)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'force_all')
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string|null $lang_id Language id (optional)
     * @param  string|null $currency_id Currency Id (optional)
     * @param  bool|null $use_latest_api_version Use the latest platform API version (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productChildItemInfo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductChildItemInfo200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productChildItemInfoWithHttpInfo($product_id, $id, $params = 'force_all', $response_fields = null, $exclude = null, $store_id = null, $lang_id = null, $currency_id = null, $use_latest_api_version = false, string $contentType = self::contentTypes['productChildItemInfo'][0])
    {
        $request = $this->productChildItemInfoRequest($product_id, $id, $params, $response_fields, $exclude, $store_id, $lang_id, $currency_id, $use_latest_api_version, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProductChildItemInfo200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProductChildItemInfo200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProductChildItemInfo200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ProductChildItemInfo200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductChildItemInfo200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productChildItemInfoAsync
     *
     * product.child_item.info
     *
     * @param  string $product_id Filter by parent product id (required)
     * @param  string $id Entity id (required)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'force_all')
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string|null $lang_id Language id (optional)
     * @param  string|null $currency_id Currency Id (optional)
     * @param  bool|null $use_latest_api_version Use the latest platform API version (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productChildItemInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productChildItemInfoAsync($product_id, $id, $params = 'force_all', $response_fields = null, $exclude = null, $store_id = null, $lang_id = null, $currency_id = null, $use_latest_api_version = false, string $contentType = self::contentTypes['productChildItemInfo'][0])
    {
        return $this->productChildItemInfoAsyncWithHttpInfo($product_id, $id, $params, $response_fields, $exclude, $store_id, $lang_id, $currency_id, $use_latest_api_version, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productChildItemInfoAsyncWithHttpInfo
     *
     * product.child_item.info
     *
     * @param  string $product_id Filter by parent product id (required)
     * @param  string $id Entity id (required)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'force_all')
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string|null $lang_id Language id (optional)
     * @param  string|null $currency_id Currency Id (optional)
     * @param  bool|null $use_latest_api_version Use the latest platform API version (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productChildItemInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productChildItemInfoAsyncWithHttpInfo($product_id, $id, $params = 'force_all', $response_fields = null, $exclude = null, $store_id = null, $lang_id = null, $currency_id = null, $use_latest_api_version = false, string $contentType = self::contentTypes['productChildItemInfo'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProductChildItemInfo200Response';
        $request = $this->productChildItemInfoRequest($product_id, $id, $params, $response_fields, $exclude, $store_id, $lang_id, $currency_id, $use_latest_api_version, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productChildItemInfo'
     *
     * @param  string $product_id Filter by parent product id (required)
     * @param  string $id Entity id (required)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'force_all')
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string|null $lang_id Language id (optional)
     * @param  string|null $currency_id Currency Id (optional)
     * @param  bool|null $use_latest_api_version Use the latest platform API version (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productChildItemInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productChildItemInfoRequest($product_id, $id, $params = 'force_all', $response_fields = null, $exclude = null, $store_id = null, $lang_id = null, $currency_id = null, $use_latest_api_version = false, string $contentType = self::contentTypes['productChildItemInfo'][0])
    {

        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_id when calling productChildItemInfo'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productChildItemInfo'
            );
        }









        $resourcePath = '/product.child_item.info.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $params,
            'params', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $response_fields,
            'response_fields', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclude,
            'exclude', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_id,
            'product_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $store_id,
            'store_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lang_id,
            'lang_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $currency_id,
            'currency_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $use_latest_api_version,
            'use_latest_api_version', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productChildItemList
     *
     * product.child_item.list
     *
     * @param  string|null $page_cursor Used to retrieve products child items via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'force_all')
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $created_from Retrieve entities from their creation date (optional)
     * @param  string|null $created_to Retrieve entities to their creation date (optional)
     * @param  string|null $modified_from Retrieve entities from their modification date (optional)
     * @param  string|null $modified_to Retrieve entities to their modification date (optional)
     * @param  string|null $product_id Filter by parent product id (optional)
     * @param  string|null $product_ids Filter by parent product ids (optional)
     * @param  string|null $sku Filter by products variant&#39;s sku (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string|null $lang_id Language id (optional)
     * @param  string|null $currency_id Currency Id (optional)
     * @param  bool|null $avail_sale Specifies the set of available/not available products for sale (optional)
     * @param  string|null $find_value Entity search that is specified by some value (optional)
     * @param  string|null $find_where Child products search that is specified by field (optional)
     * @param  string|null $report_request_id Report request id (optional)
     * @param  bool|null $disable_report_cache Disable report cache for current request (optional, default to false)
     * @param  bool|null $use_latest_api_version Use the latest platform API version (optional, default to false)
     * @param  bool|null $return_global Determines the type of products to be returned. If set to &#39;true&#39;, only global products will be returned; if set to &#39;false&#39;, only local products will be returned. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productChildItemList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModelResponseProductChildItemList
     */
    public function productChildItemList($page_cursor = null, $start = 0, $count = 10, $params = 'force_all', $response_fields = null, $exclude = null, $created_from = null, $created_to = null, $modified_from = null, $modified_to = null, $product_id = null, $product_ids = null, $sku = null, $store_id = null, $lang_id = null, $currency_id = null, $avail_sale = null, $find_value = null, $find_where = null, $report_request_id = null, $disable_report_cache = false, $use_latest_api_version = false, $return_global = false, string $contentType = self::contentTypes['productChildItemList'][0])
    {
        list($response) = $this->productChildItemListWithHttpInfo($page_cursor, $start, $count, $params, $response_fields, $exclude, $created_from, $created_to, $modified_from, $modified_to, $product_id, $product_ids, $sku, $store_id, $lang_id, $currency_id, $avail_sale, $find_value, $find_where, $report_request_id, $disable_report_cache, $use_latest_api_version, $return_global, $contentType);
        return $response;
    }

    /**
     * Operation productChildItemListWithHttpInfo
     *
     * product.child_item.list
     *
     * @param  string|null $page_cursor Used to retrieve products child items via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'force_all')
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $created_from Retrieve entities from their creation date (optional)
     * @param  string|null $created_to Retrieve entities to their creation date (optional)
     * @param  string|null $modified_from Retrieve entities from their modification date (optional)
     * @param  string|null $modified_to Retrieve entities to their modification date (optional)
     * @param  string|null $product_id Filter by parent product id (optional)
     * @param  string|null $product_ids Filter by parent product ids (optional)
     * @param  string|null $sku Filter by products variant&#39;s sku (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string|null $lang_id Language id (optional)
     * @param  string|null $currency_id Currency Id (optional)
     * @param  bool|null $avail_sale Specifies the set of available/not available products for sale (optional)
     * @param  string|null $find_value Entity search that is specified by some value (optional)
     * @param  string|null $find_where Child products search that is specified by field (optional)
     * @param  string|null $report_request_id Report request id (optional)
     * @param  bool|null $disable_report_cache Disable report cache for current request (optional, default to false)
     * @param  bool|null $use_latest_api_version Use the latest platform API version (optional, default to false)
     * @param  bool|null $return_global Determines the type of products to be returned. If set to &#39;true&#39;, only global products will be returned; if set to &#39;false&#39;, only local products will be returned. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productChildItemList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModelResponseProductChildItemList, HTTP status code, HTTP response headers (array of strings)
     */
    public function productChildItemListWithHttpInfo($page_cursor = null, $start = 0, $count = 10, $params = 'force_all', $response_fields = null, $exclude = null, $created_from = null, $created_to = null, $modified_from = null, $modified_to = null, $product_id = null, $product_ids = null, $sku = null, $store_id = null, $lang_id = null, $currency_id = null, $avail_sale = null, $find_value = null, $find_where = null, $report_request_id = null, $disable_report_cache = false, $use_latest_api_version = false, $return_global = false, string $contentType = self::contentTypes['productChildItemList'][0])
    {
        $request = $this->productChildItemListRequest($page_cursor, $start, $count, $params, $response_fields, $exclude, $created_from, $created_to, $modified_from, $modified_to, $product_id, $product_ids, $sku, $store_id, $lang_id, $currency_id, $avail_sale, $find_value, $find_where, $report_request_id, $disable_report_cache, $use_latest_api_version, $return_global, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModelResponseProductChildItemList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ModelResponseProductChildItemList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModelResponseProductChildItemList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ModelResponseProductChildItemList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModelResponseProductChildItemList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productChildItemListAsync
     *
     * product.child_item.list
     *
     * @param  string|null $page_cursor Used to retrieve products child items via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'force_all')
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $created_from Retrieve entities from their creation date (optional)
     * @param  string|null $created_to Retrieve entities to their creation date (optional)
     * @param  string|null $modified_from Retrieve entities from their modification date (optional)
     * @param  string|null $modified_to Retrieve entities to their modification date (optional)
     * @param  string|null $product_id Filter by parent product id (optional)
     * @param  string|null $product_ids Filter by parent product ids (optional)
     * @param  string|null $sku Filter by products variant&#39;s sku (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string|null $lang_id Language id (optional)
     * @param  string|null $currency_id Currency Id (optional)
     * @param  bool|null $avail_sale Specifies the set of available/not available products for sale (optional)
     * @param  string|null $find_value Entity search that is specified by some value (optional)
     * @param  string|null $find_where Child products search that is specified by field (optional)
     * @param  string|null $report_request_id Report request id (optional)
     * @param  bool|null $disable_report_cache Disable report cache for current request (optional, default to false)
     * @param  bool|null $use_latest_api_version Use the latest platform API version (optional, default to false)
     * @param  bool|null $return_global Determines the type of products to be returned. If set to &#39;true&#39;, only global products will be returned; if set to &#39;false&#39;, only local products will be returned. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productChildItemList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productChildItemListAsync($page_cursor = null, $start = 0, $count = 10, $params = 'force_all', $response_fields = null, $exclude = null, $created_from = null, $created_to = null, $modified_from = null, $modified_to = null, $product_id = null, $product_ids = null, $sku = null, $store_id = null, $lang_id = null, $currency_id = null, $avail_sale = null, $find_value = null, $find_where = null, $report_request_id = null, $disable_report_cache = false, $use_latest_api_version = false, $return_global = false, string $contentType = self::contentTypes['productChildItemList'][0])
    {
        return $this->productChildItemListAsyncWithHttpInfo($page_cursor, $start, $count, $params, $response_fields, $exclude, $created_from, $created_to, $modified_from, $modified_to, $product_id, $product_ids, $sku, $store_id, $lang_id, $currency_id, $avail_sale, $find_value, $find_where, $report_request_id, $disable_report_cache, $use_latest_api_version, $return_global, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productChildItemListAsyncWithHttpInfo
     *
     * product.child_item.list
     *
     * @param  string|null $page_cursor Used to retrieve products child items via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'force_all')
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $created_from Retrieve entities from their creation date (optional)
     * @param  string|null $created_to Retrieve entities to their creation date (optional)
     * @param  string|null $modified_from Retrieve entities from their modification date (optional)
     * @param  string|null $modified_to Retrieve entities to their modification date (optional)
     * @param  string|null $product_id Filter by parent product id (optional)
     * @param  string|null $product_ids Filter by parent product ids (optional)
     * @param  string|null $sku Filter by products variant&#39;s sku (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string|null $lang_id Language id (optional)
     * @param  string|null $currency_id Currency Id (optional)
     * @param  bool|null $avail_sale Specifies the set of available/not available products for sale (optional)
     * @param  string|null $find_value Entity search that is specified by some value (optional)
     * @param  string|null $find_where Child products search that is specified by field (optional)
     * @param  string|null $report_request_id Report request id (optional)
     * @param  bool|null $disable_report_cache Disable report cache for current request (optional, default to false)
     * @param  bool|null $use_latest_api_version Use the latest platform API version (optional, default to false)
     * @param  bool|null $return_global Determines the type of products to be returned. If set to &#39;true&#39;, only global products will be returned; if set to &#39;false&#39;, only local products will be returned. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productChildItemList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productChildItemListAsyncWithHttpInfo($page_cursor = null, $start = 0, $count = 10, $params = 'force_all', $response_fields = null, $exclude = null, $created_from = null, $created_to = null, $modified_from = null, $modified_to = null, $product_id = null, $product_ids = null, $sku = null, $store_id = null, $lang_id = null, $currency_id = null, $avail_sale = null, $find_value = null, $find_where = null, $report_request_id = null, $disable_report_cache = false, $use_latest_api_version = false, $return_global = false, string $contentType = self::contentTypes['productChildItemList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ModelResponseProductChildItemList';
        $request = $this->productChildItemListRequest($page_cursor, $start, $count, $params, $response_fields, $exclude, $created_from, $created_to, $modified_from, $modified_to, $product_id, $product_ids, $sku, $store_id, $lang_id, $currency_id, $avail_sale, $find_value, $find_where, $report_request_id, $disable_report_cache, $use_latest_api_version, $return_global, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productChildItemList'
     *
     * @param  string|null $page_cursor Used to retrieve products child items via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'force_all')
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $created_from Retrieve entities from their creation date (optional)
     * @param  string|null $created_to Retrieve entities to their creation date (optional)
     * @param  string|null $modified_from Retrieve entities from their modification date (optional)
     * @param  string|null $modified_to Retrieve entities to their modification date (optional)
     * @param  string|null $product_id Filter by parent product id (optional)
     * @param  string|null $product_ids Filter by parent product ids (optional)
     * @param  string|null $sku Filter by products variant&#39;s sku (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string|null $lang_id Language id (optional)
     * @param  string|null $currency_id Currency Id (optional)
     * @param  bool|null $avail_sale Specifies the set of available/not available products for sale (optional)
     * @param  string|null $find_value Entity search that is specified by some value (optional)
     * @param  string|null $find_where Child products search that is specified by field (optional)
     * @param  string|null $report_request_id Report request id (optional)
     * @param  bool|null $disable_report_cache Disable report cache for current request (optional, default to false)
     * @param  bool|null $use_latest_api_version Use the latest platform API version (optional, default to false)
     * @param  bool|null $return_global Determines the type of products to be returned. If set to &#39;true&#39;, only global products will be returned; if set to &#39;false&#39;, only local products will be returned. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productChildItemList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productChildItemListRequest($page_cursor = null, $start = 0, $count = 10, $params = 'force_all', $response_fields = null, $exclude = null, $created_from = null, $created_to = null, $modified_from = null, $modified_to = null, $product_id = null, $product_ids = null, $sku = null, $store_id = null, $lang_id = null, $currency_id = null, $avail_sale = null, $find_value = null, $find_where = null, $report_request_id = null, $disable_report_cache = false, $use_latest_api_version = false, $return_global = false, string $contentType = self::contentTypes['productChildItemList'][0])
    {

























        $resourcePath = '/product.child_item.list.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_cursor,
            'page_cursor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $params,
            'params', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $response_fields,
            'response_fields', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclude,
            'exclude', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_from,
            'created_from', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_to,
            'created_to', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_from,
            'modified_from', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_to,
            'modified_to', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_id,
            'product_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_ids,
            'product_ids', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sku,
            'sku', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $store_id,
            'store_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lang_id,
            'lang_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $currency_id,
            'currency_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $avail_sale,
            'avail_sale', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $find_value,
            'find_value', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $find_where,
            'find_where', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $report_request_id,
            'report_request_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $disable_report_cache,
            'disable_report_cache', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $use_latest_api_version,
            'use_latest_api_version', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_global,
            'return_global', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productCount
     *
     * product.count
     *
     * @param  string|null $category_id Counts products specified by category id (optional)
     * @param  string|null $created_from Retrieve entities from their creation date (optional)
     * @param  string|null $created_to Retrieve entities to their creation date (optional)
     * @param  string|null $modified_from Retrieve entities from their modification date (optional)
     * @param  string|null $modified_to Retrieve entities to their modification date (optional)
     * @param  bool|null $avail_view Specifies the set of visible/invisible products (optional)
     * @param  bool|null $avail_sale Specifies the set of available/not available products for sale (optional)
     * @param  string|null $store_id Counts products specified by store id (optional)
     * @param  string|null $lang_id Counts products specified by language id (optional)
     * @param  string|null $product_ids Counts products specified by product ids (optional)
     * @param  string|null $since_id Retrieve entities starting from the specified id. (optional)
     * @param  string|null $report_request_id Report request id (optional)
     * @param  bool|null $disable_report_cache Disable report cache for current request (optional, default to false)
     * @param  string|null $brand_name Retrieves brands specified by brand name (optional)
     * @param  string[]|null $product_attributes Defines product attributes (optional)
     * @param  string|null $status Defines product&#39;s status (optional)
     * @param  string|null $type Defines products&#39;s type (optional)
     * @param  string|null $find_value Entity search that is specified by some value (optional)
     * @param  string|null $find_where Counts products that are searched specified by field (optional)
     * @param  bool|null $use_latest_api_version Use the latest platform API version (optional, default to false)
     * @param  bool|null $return_global Determines the type of products to be returned. If set to &#39;true&#39;, only global products will be returned; if set to &#39;false&#39;, only local products will be returned. (optional, default to false)
     * @param  string|null $categories_ids Defines product add that is specified by comma-separated categories id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productCount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductCount200Response
     */
    public function productCount($category_id = null, $created_from = null, $created_to = null, $modified_from = null, $modified_to = null, $avail_view = null, $avail_sale = null, $store_id = null, $lang_id = null, $product_ids = null, $since_id = null, $report_request_id = null, $disable_report_cache = false, $brand_name = null, $product_attributes = null, $status = null, $type = null, $find_value = null, $find_where = null, $use_latest_api_version = false, $return_global = false, $categories_ids = null, string $contentType = self::contentTypes['productCount'][0])
    {
        list($response) = $this->productCountWithHttpInfo($category_id, $created_from, $created_to, $modified_from, $modified_to, $avail_view, $avail_sale, $store_id, $lang_id, $product_ids, $since_id, $report_request_id, $disable_report_cache, $brand_name, $product_attributes, $status, $type, $find_value, $find_where, $use_latest_api_version, $return_global, $categories_ids, $contentType);
        return $response;
    }

    /**
     * Operation productCountWithHttpInfo
     *
     * product.count
     *
     * @param  string|null $category_id Counts products specified by category id (optional)
     * @param  string|null $created_from Retrieve entities from their creation date (optional)
     * @param  string|null $created_to Retrieve entities to their creation date (optional)
     * @param  string|null $modified_from Retrieve entities from their modification date (optional)
     * @param  string|null $modified_to Retrieve entities to their modification date (optional)
     * @param  bool|null $avail_view Specifies the set of visible/invisible products (optional)
     * @param  bool|null $avail_sale Specifies the set of available/not available products for sale (optional)
     * @param  string|null $store_id Counts products specified by store id (optional)
     * @param  string|null $lang_id Counts products specified by language id (optional)
     * @param  string|null $product_ids Counts products specified by product ids (optional)
     * @param  string|null $since_id Retrieve entities starting from the specified id. (optional)
     * @param  string|null $report_request_id Report request id (optional)
     * @param  bool|null $disable_report_cache Disable report cache for current request (optional, default to false)
     * @param  string|null $brand_name Retrieves brands specified by brand name (optional)
     * @param  string[]|null $product_attributes Defines product attributes (optional)
     * @param  string|null $status Defines product&#39;s status (optional)
     * @param  string|null $type Defines products&#39;s type (optional)
     * @param  string|null $find_value Entity search that is specified by some value (optional)
     * @param  string|null $find_where Counts products that are searched specified by field (optional)
     * @param  bool|null $use_latest_api_version Use the latest platform API version (optional, default to false)
     * @param  bool|null $return_global Determines the type of products to be returned. If set to &#39;true&#39;, only global products will be returned; if set to &#39;false&#39;, only local products will be returned. (optional, default to false)
     * @param  string|null $categories_ids Defines product add that is specified by comma-separated categories id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productCount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductCount200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productCountWithHttpInfo($category_id = null, $created_from = null, $created_to = null, $modified_from = null, $modified_to = null, $avail_view = null, $avail_sale = null, $store_id = null, $lang_id = null, $product_ids = null, $since_id = null, $report_request_id = null, $disable_report_cache = false, $brand_name = null, $product_attributes = null, $status = null, $type = null, $find_value = null, $find_where = null, $use_latest_api_version = false, $return_global = false, $categories_ids = null, string $contentType = self::contentTypes['productCount'][0])
    {
        $request = $this->productCountRequest($category_id, $created_from, $created_to, $modified_from, $modified_to, $avail_view, $avail_sale, $store_id, $lang_id, $product_ids, $since_id, $report_request_id, $disable_report_cache, $brand_name, $product_attributes, $status, $type, $find_value, $find_where, $use_latest_api_version, $return_global, $categories_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProductCount200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProductCount200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProductCount200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ProductCount200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductCount200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productCountAsync
     *
     * product.count
     *
     * @param  string|null $category_id Counts products specified by category id (optional)
     * @param  string|null $created_from Retrieve entities from their creation date (optional)
     * @param  string|null $created_to Retrieve entities to their creation date (optional)
     * @param  string|null $modified_from Retrieve entities from their modification date (optional)
     * @param  string|null $modified_to Retrieve entities to their modification date (optional)
     * @param  bool|null $avail_view Specifies the set of visible/invisible products (optional)
     * @param  bool|null $avail_sale Specifies the set of available/not available products for sale (optional)
     * @param  string|null $store_id Counts products specified by store id (optional)
     * @param  string|null $lang_id Counts products specified by language id (optional)
     * @param  string|null $product_ids Counts products specified by product ids (optional)
     * @param  string|null $since_id Retrieve entities starting from the specified id. (optional)
     * @param  string|null $report_request_id Report request id (optional)
     * @param  bool|null $disable_report_cache Disable report cache for current request (optional, default to false)
     * @param  string|null $brand_name Retrieves brands specified by brand name (optional)
     * @param  string[]|null $product_attributes Defines product attributes (optional)
     * @param  string|null $status Defines product&#39;s status (optional)
     * @param  string|null $type Defines products&#39;s type (optional)
     * @param  string|null $find_value Entity search that is specified by some value (optional)
     * @param  string|null $find_where Counts products that are searched specified by field (optional)
     * @param  bool|null $use_latest_api_version Use the latest platform API version (optional, default to false)
     * @param  bool|null $return_global Determines the type of products to be returned. If set to &#39;true&#39;, only global products will be returned; if set to &#39;false&#39;, only local products will be returned. (optional, default to false)
     * @param  string|null $categories_ids Defines product add that is specified by comma-separated categories id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productCountAsync($category_id = null, $created_from = null, $created_to = null, $modified_from = null, $modified_to = null, $avail_view = null, $avail_sale = null, $store_id = null, $lang_id = null, $product_ids = null, $since_id = null, $report_request_id = null, $disable_report_cache = false, $brand_name = null, $product_attributes = null, $status = null, $type = null, $find_value = null, $find_where = null, $use_latest_api_version = false, $return_global = false, $categories_ids = null, string $contentType = self::contentTypes['productCount'][0])
    {
        return $this->productCountAsyncWithHttpInfo($category_id, $created_from, $created_to, $modified_from, $modified_to, $avail_view, $avail_sale, $store_id, $lang_id, $product_ids, $since_id, $report_request_id, $disable_report_cache, $brand_name, $product_attributes, $status, $type, $find_value, $find_where, $use_latest_api_version, $return_global, $categories_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productCountAsyncWithHttpInfo
     *
     * product.count
     *
     * @param  string|null $category_id Counts products specified by category id (optional)
     * @param  string|null $created_from Retrieve entities from their creation date (optional)
     * @param  string|null $created_to Retrieve entities to their creation date (optional)
     * @param  string|null $modified_from Retrieve entities from their modification date (optional)
     * @param  string|null $modified_to Retrieve entities to their modification date (optional)
     * @param  bool|null $avail_view Specifies the set of visible/invisible products (optional)
     * @param  bool|null $avail_sale Specifies the set of available/not available products for sale (optional)
     * @param  string|null $store_id Counts products specified by store id (optional)
     * @param  string|null $lang_id Counts products specified by language id (optional)
     * @param  string|null $product_ids Counts products specified by product ids (optional)
     * @param  string|null $since_id Retrieve entities starting from the specified id. (optional)
     * @param  string|null $report_request_id Report request id (optional)
     * @param  bool|null $disable_report_cache Disable report cache for current request (optional, default to false)
     * @param  string|null $brand_name Retrieves brands specified by brand name (optional)
     * @param  string[]|null $product_attributes Defines product attributes (optional)
     * @param  string|null $status Defines product&#39;s status (optional)
     * @param  string|null $type Defines products&#39;s type (optional)
     * @param  string|null $find_value Entity search that is specified by some value (optional)
     * @param  string|null $find_where Counts products that are searched specified by field (optional)
     * @param  bool|null $use_latest_api_version Use the latest platform API version (optional, default to false)
     * @param  bool|null $return_global Determines the type of products to be returned. If set to &#39;true&#39;, only global products will be returned; if set to &#39;false&#39;, only local products will be returned. (optional, default to false)
     * @param  string|null $categories_ids Defines product add that is specified by comma-separated categories id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productCountAsyncWithHttpInfo($category_id = null, $created_from = null, $created_to = null, $modified_from = null, $modified_to = null, $avail_view = null, $avail_sale = null, $store_id = null, $lang_id = null, $product_ids = null, $since_id = null, $report_request_id = null, $disable_report_cache = false, $brand_name = null, $product_attributes = null, $status = null, $type = null, $find_value = null, $find_where = null, $use_latest_api_version = false, $return_global = false, $categories_ids = null, string $contentType = self::contentTypes['productCount'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProductCount200Response';
        $request = $this->productCountRequest($category_id, $created_from, $created_to, $modified_from, $modified_to, $avail_view, $avail_sale, $store_id, $lang_id, $product_ids, $since_id, $report_request_id, $disable_report_cache, $brand_name, $product_attributes, $status, $type, $find_value, $find_where, $use_latest_api_version, $return_global, $categories_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productCount'
     *
     * @param  string|null $category_id Counts products specified by category id (optional)
     * @param  string|null $created_from Retrieve entities from their creation date (optional)
     * @param  string|null $created_to Retrieve entities to their creation date (optional)
     * @param  string|null $modified_from Retrieve entities from their modification date (optional)
     * @param  string|null $modified_to Retrieve entities to their modification date (optional)
     * @param  bool|null $avail_view Specifies the set of visible/invisible products (optional)
     * @param  bool|null $avail_sale Specifies the set of available/not available products for sale (optional)
     * @param  string|null $store_id Counts products specified by store id (optional)
     * @param  string|null $lang_id Counts products specified by language id (optional)
     * @param  string|null $product_ids Counts products specified by product ids (optional)
     * @param  string|null $since_id Retrieve entities starting from the specified id. (optional)
     * @param  string|null $report_request_id Report request id (optional)
     * @param  bool|null $disable_report_cache Disable report cache for current request (optional, default to false)
     * @param  string|null $brand_name Retrieves brands specified by brand name (optional)
     * @param  string[]|null $product_attributes Defines product attributes (optional)
     * @param  string|null $status Defines product&#39;s status (optional)
     * @param  string|null $type Defines products&#39;s type (optional)
     * @param  string|null $find_value Entity search that is specified by some value (optional)
     * @param  string|null $find_where Counts products that are searched specified by field (optional)
     * @param  bool|null $use_latest_api_version Use the latest platform API version (optional, default to false)
     * @param  bool|null $return_global Determines the type of products to be returned. If set to &#39;true&#39;, only global products will be returned; if set to &#39;false&#39;, only local products will be returned. (optional, default to false)
     * @param  string|null $categories_ids Defines product add that is specified by comma-separated categories id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productCountRequest($category_id = null, $created_from = null, $created_to = null, $modified_from = null, $modified_to = null, $avail_view = null, $avail_sale = null, $store_id = null, $lang_id = null, $product_ids = null, $since_id = null, $report_request_id = null, $disable_report_cache = false, $brand_name = null, $product_attributes = null, $status = null, $type = null, $find_value = null, $find_where = null, $use_latest_api_version = false, $return_global = false, $categories_ids = null, string $contentType = self::contentTypes['productCount'][0])
    {
























        $resourcePath = '/product.count.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category_id,
            'category_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_from,
            'created_from', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_to,
            'created_to', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_from,
            'modified_from', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_to,
            'modified_to', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $avail_view,
            'avail_view', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $avail_sale,
            'avail_sale', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $store_id,
            'store_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lang_id,
            'lang_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_ids,
            'product_ids', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $since_id,
            'since_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $report_request_id,
            'report_request_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $disable_report_cache,
            'disable_report_cache', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $brand_name,
            'brand_name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_attributes,
            'product_attributes', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $find_value,
            'find_value', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $find_where,
            'find_where', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $use_latest_api_version,
            'use_latest_api_version', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_global,
            'return_global', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $categories_ids,
            'categories_ids', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productCurrencyAdd
     *
     * product.currency.add
     *
     * @param  string $iso3 Specifies standardized currency code (required)
     * @param  float $rate Defines the numerical identifier against to the major currency (required)
     * @param  string|null $name Defines currency&#39;s name (optional)
     * @param  bool|null $avail Specifies whether the currency is available (optional, default to true)
     * @param  string|null $symbol_left Defines the symbol that is located before the currency (optional)
     * @param  string|null $symbol_right Defines the symbol that is located after the currency (optional)
     * @param  bool|null $default Specifies currency&#39;s default meaning (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productCurrencyAdd'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductCurrencyAdd200Response
     */
    public function productCurrencyAdd($iso3, $rate, $name = null, $avail = true, $symbol_left = null, $symbol_right = null, $default = false, string $contentType = self::contentTypes['productCurrencyAdd'][0])
    {
        list($response) = $this->productCurrencyAddWithHttpInfo($iso3, $rate, $name, $avail, $symbol_left, $symbol_right, $default, $contentType);
        return $response;
    }

    /**
     * Operation productCurrencyAddWithHttpInfo
     *
     * product.currency.add
     *
     * @param  string $iso3 Specifies standardized currency code (required)
     * @param  float $rate Defines the numerical identifier against to the major currency (required)
     * @param  string|null $name Defines currency&#39;s name (optional)
     * @param  bool|null $avail Specifies whether the currency is available (optional, default to true)
     * @param  string|null $symbol_left Defines the symbol that is located before the currency (optional)
     * @param  string|null $symbol_right Defines the symbol that is located after the currency (optional)
     * @param  bool|null $default Specifies currency&#39;s default meaning (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productCurrencyAdd'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductCurrencyAdd200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productCurrencyAddWithHttpInfo($iso3, $rate, $name = null, $avail = true, $symbol_left = null, $symbol_right = null, $default = false, string $contentType = self::contentTypes['productCurrencyAdd'][0])
    {
        $request = $this->productCurrencyAddRequest($iso3, $rate, $name, $avail, $symbol_left, $symbol_right, $default, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProductCurrencyAdd200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProductCurrencyAdd200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProductCurrencyAdd200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ProductCurrencyAdd200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductCurrencyAdd200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productCurrencyAddAsync
     *
     * product.currency.add
     *
     * @param  string $iso3 Specifies standardized currency code (required)
     * @param  float $rate Defines the numerical identifier against to the major currency (required)
     * @param  string|null $name Defines currency&#39;s name (optional)
     * @param  bool|null $avail Specifies whether the currency is available (optional, default to true)
     * @param  string|null $symbol_left Defines the symbol that is located before the currency (optional)
     * @param  string|null $symbol_right Defines the symbol that is located after the currency (optional)
     * @param  bool|null $default Specifies currency&#39;s default meaning (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productCurrencyAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productCurrencyAddAsync($iso3, $rate, $name = null, $avail = true, $symbol_left = null, $symbol_right = null, $default = false, string $contentType = self::contentTypes['productCurrencyAdd'][0])
    {
        return $this->productCurrencyAddAsyncWithHttpInfo($iso3, $rate, $name, $avail, $symbol_left, $symbol_right, $default, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productCurrencyAddAsyncWithHttpInfo
     *
     * product.currency.add
     *
     * @param  string $iso3 Specifies standardized currency code (required)
     * @param  float $rate Defines the numerical identifier against to the major currency (required)
     * @param  string|null $name Defines currency&#39;s name (optional)
     * @param  bool|null $avail Specifies whether the currency is available (optional, default to true)
     * @param  string|null $symbol_left Defines the symbol that is located before the currency (optional)
     * @param  string|null $symbol_right Defines the symbol that is located after the currency (optional)
     * @param  bool|null $default Specifies currency&#39;s default meaning (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productCurrencyAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productCurrencyAddAsyncWithHttpInfo($iso3, $rate, $name = null, $avail = true, $symbol_left = null, $symbol_right = null, $default = false, string $contentType = self::contentTypes['productCurrencyAdd'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProductCurrencyAdd200Response';
        $request = $this->productCurrencyAddRequest($iso3, $rate, $name, $avail, $symbol_left, $symbol_right, $default, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productCurrencyAdd'
     *
     * @param  string $iso3 Specifies standardized currency code (required)
     * @param  float $rate Defines the numerical identifier against to the major currency (required)
     * @param  string|null $name Defines currency&#39;s name (optional)
     * @param  bool|null $avail Specifies whether the currency is available (optional, default to true)
     * @param  string|null $symbol_left Defines the symbol that is located before the currency (optional)
     * @param  string|null $symbol_right Defines the symbol that is located after the currency (optional)
     * @param  bool|null $default Specifies currency&#39;s default meaning (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productCurrencyAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productCurrencyAddRequest($iso3, $rate, $name = null, $avail = true, $symbol_left = null, $symbol_right = null, $default = false, string $contentType = self::contentTypes['productCurrencyAdd'][0])
    {

        // verify the required parameter 'iso3' is set
        if ($iso3 === null || (is_array($iso3) && count($iso3) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $iso3 when calling productCurrencyAdd'
            );
        }

        // verify the required parameter 'rate' is set
        if ($rate === null || (is_array($rate) && count($rate) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rate when calling productCurrencyAdd'
            );
        }







        $resourcePath = '/product.currency.add.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $iso3,
            'iso3', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rate,
            'rate', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $avail,
            'avail', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol_left,
            'symbol_left', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol_right,
            'symbol_right', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $default,
            'default', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productCurrencyList
     *
     * product.currency.list
     *
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'name,iso3,default,avail')
     * @param  string|null $page_cursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  bool|null $default Specifies the set of default/not default currencies (optional)
     * @param  bool|null $avail Specifies the set of available/not available currencies (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productCurrencyList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModelResponseProductCurrencyList
     */
    public function productCurrencyList($start = 0, $count = 10, $params = 'name,iso3,default,avail', $page_cursor = null, $exclude = null, $response_fields = null, $default = null, $avail = null, string $contentType = self::contentTypes['productCurrencyList'][0])
    {
        list($response) = $this->productCurrencyListWithHttpInfo($start, $count, $params, $page_cursor, $exclude, $response_fields, $default, $avail, $contentType);
        return $response;
    }

    /**
     * Operation productCurrencyListWithHttpInfo
     *
     * product.currency.list
     *
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'name,iso3,default,avail')
     * @param  string|null $page_cursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  bool|null $default Specifies the set of default/not default currencies (optional)
     * @param  bool|null $avail Specifies the set of available/not available currencies (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productCurrencyList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModelResponseProductCurrencyList, HTTP status code, HTTP response headers (array of strings)
     */
    public function productCurrencyListWithHttpInfo($start = 0, $count = 10, $params = 'name,iso3,default,avail', $page_cursor = null, $exclude = null, $response_fields = null, $default = null, $avail = null, string $contentType = self::contentTypes['productCurrencyList'][0])
    {
        $request = $this->productCurrencyListRequest($start, $count, $params, $page_cursor, $exclude, $response_fields, $default, $avail, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModelResponseProductCurrencyList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ModelResponseProductCurrencyList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModelResponseProductCurrencyList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ModelResponseProductCurrencyList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModelResponseProductCurrencyList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productCurrencyListAsync
     *
     * product.currency.list
     *
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'name,iso3,default,avail')
     * @param  string|null $page_cursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  bool|null $default Specifies the set of default/not default currencies (optional)
     * @param  bool|null $avail Specifies the set of available/not available currencies (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productCurrencyList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productCurrencyListAsync($start = 0, $count = 10, $params = 'name,iso3,default,avail', $page_cursor = null, $exclude = null, $response_fields = null, $default = null, $avail = null, string $contentType = self::contentTypes['productCurrencyList'][0])
    {
        return $this->productCurrencyListAsyncWithHttpInfo($start, $count, $params, $page_cursor, $exclude, $response_fields, $default, $avail, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productCurrencyListAsyncWithHttpInfo
     *
     * product.currency.list
     *
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'name,iso3,default,avail')
     * @param  string|null $page_cursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  bool|null $default Specifies the set of default/not default currencies (optional)
     * @param  bool|null $avail Specifies the set of available/not available currencies (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productCurrencyList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productCurrencyListAsyncWithHttpInfo($start = 0, $count = 10, $params = 'name,iso3,default,avail', $page_cursor = null, $exclude = null, $response_fields = null, $default = null, $avail = null, string $contentType = self::contentTypes['productCurrencyList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ModelResponseProductCurrencyList';
        $request = $this->productCurrencyListRequest($start, $count, $params, $page_cursor, $exclude, $response_fields, $default, $avail, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productCurrencyList'
     *
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'name,iso3,default,avail')
     * @param  string|null $page_cursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  bool|null $default Specifies the set of default/not default currencies (optional)
     * @param  bool|null $avail Specifies the set of available/not available currencies (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productCurrencyList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productCurrencyListRequest($start = 0, $count = 10, $params = 'name,iso3,default,avail', $page_cursor = null, $exclude = null, $response_fields = null, $default = null, $avail = null, string $contentType = self::contentTypes['productCurrencyList'][0])
    {










        $resourcePath = '/product.currency.list.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $params,
            'params', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_cursor,
            'page_cursor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclude,
            'exclude', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $response_fields,
            'response_fields', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $default,
            'default', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $avail,
            'avail', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productDelete
     *
     * product.delete
     *
     * @param  string $id Product id that will be removed (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CustomerDelete200Response
     */
    public function productDelete($id, $store_id = null, string $contentType = self::contentTypes['productDelete'][0])
    {
        list($response) = $this->productDeleteWithHttpInfo($id, $store_id, $contentType);
        return $response;
    }

    /**
     * Operation productDeleteWithHttpInfo
     *
     * product.delete
     *
     * @param  string $id Product id that will be removed (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CustomerDelete200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productDeleteWithHttpInfo($id, $store_id = null, string $contentType = self::contentTypes['productDelete'][0])
    {
        $request = $this->productDeleteRequest($id, $store_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CustomerDelete200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CustomerDelete200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CustomerDelete200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\CustomerDelete200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CustomerDelete200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productDeleteAsync
     *
     * product.delete
     *
     * @param  string $id Product id that will be removed (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productDeleteAsync($id, $store_id = null, string $contentType = self::contentTypes['productDelete'][0])
    {
        return $this->productDeleteAsyncWithHttpInfo($id, $store_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productDeleteAsyncWithHttpInfo
     *
     * product.delete
     *
     * @param  string $id Product id that will be removed (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productDeleteAsyncWithHttpInfo($id, $store_id = null, string $contentType = self::contentTypes['productDelete'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CustomerDelete200Response';
        $request = $this->productDeleteRequest($id, $store_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productDelete'
     *
     * @param  string $id Product id that will be removed (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productDeleteRequest($id, $store_id = null, string $contentType = self::contentTypes['productDelete'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productDelete'
            );
        }



        $resourcePath = '/product.delete.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $store_id,
            'store_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productDeleteBatch
     *
     * product.delete.batch
     *
     * @param  \OpenAPI\Client\Model\ProductDeleteBatch $product_delete_batch product_delete_batch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productDeleteBatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CategoryAddBatch200Response
     */
    public function productDeleteBatch($product_delete_batch, string $contentType = self::contentTypes['productDeleteBatch'][0])
    {
        list($response) = $this->productDeleteBatchWithHttpInfo($product_delete_batch, $contentType);
        return $response;
    }

    /**
     * Operation productDeleteBatchWithHttpInfo
     *
     * product.delete.batch
     *
     * @param  \OpenAPI\Client\Model\ProductDeleteBatch $product_delete_batch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productDeleteBatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CategoryAddBatch200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productDeleteBatchWithHttpInfo($product_delete_batch, string $contentType = self::contentTypes['productDeleteBatch'][0])
    {
        $request = $this->productDeleteBatchRequest($product_delete_batch, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CategoryAddBatch200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CategoryAddBatch200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CategoryAddBatch200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\CategoryAddBatch200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CategoryAddBatch200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productDeleteBatchAsync
     *
     * product.delete.batch
     *
     * @param  \OpenAPI\Client\Model\ProductDeleteBatch $product_delete_batch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productDeleteBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productDeleteBatchAsync($product_delete_batch, string $contentType = self::contentTypes['productDeleteBatch'][0])
    {
        return $this->productDeleteBatchAsyncWithHttpInfo($product_delete_batch, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productDeleteBatchAsyncWithHttpInfo
     *
     * product.delete.batch
     *
     * @param  \OpenAPI\Client\Model\ProductDeleteBatch $product_delete_batch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productDeleteBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productDeleteBatchAsyncWithHttpInfo($product_delete_batch, string $contentType = self::contentTypes['productDeleteBatch'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CategoryAddBatch200Response';
        $request = $this->productDeleteBatchRequest($product_delete_batch, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productDeleteBatch'
     *
     * @param  \OpenAPI\Client\Model\ProductDeleteBatch $product_delete_batch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productDeleteBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productDeleteBatchRequest($product_delete_batch, string $contentType = self::contentTypes['productDeleteBatch'][0])
    {

        // verify the required parameter 'product_delete_batch' is set
        if ($product_delete_batch === null || (is_array($product_delete_batch) && count($product_delete_batch) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_delete_batch when calling productDeleteBatch'
            );
        }


        $resourcePath = '/product.delete.batch.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($product_delete_batch)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($product_delete_batch));
            } else {
                $httpBody = $product_delete_batch;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productFields
     *
     * product.fields
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productFields'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CartConfigUpdate200Response
     * @deprecated
     */
    public function productFields(string $contentType = self::contentTypes['productFields'][0])
    {
        list($response) = $this->productFieldsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation productFieldsWithHttpInfo
     *
     * product.fields
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productFields'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CartConfigUpdate200Response, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function productFieldsWithHttpInfo(string $contentType = self::contentTypes['productFields'][0])
    {
        $request = $this->productFieldsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CartConfigUpdate200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CartConfigUpdate200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CartConfigUpdate200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\CartConfigUpdate200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CartConfigUpdate200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productFieldsAsync
     *
     * product.fields
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productFields'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function productFieldsAsync(string $contentType = self::contentTypes['productFields'][0])
    {
        return $this->productFieldsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productFieldsAsyncWithHttpInfo
     *
     * product.fields
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productFields'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function productFieldsAsyncWithHttpInfo(string $contentType = self::contentTypes['productFields'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CartConfigUpdate200Response';
        $request = $this->productFieldsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productFields'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productFields'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function productFieldsRequest(string $contentType = self::contentTypes['productFields'][0])
    {


        $resourcePath = '/product.fields.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productFind
     *
     * product.find
     *
     * @param  string $find_value Entity search that is specified by some value (required)
     * @param  string|null $find_where Entity search that is specified by the comma-separated unique fields (optional, default to 'name')
     * @param  string|null $find_params Entity search that is specified by comma-separated parameters (optional, default to 'whole_words')
     * @param  string|null $find_what Parameter&#39;s value specifies the entity that has to be found (optional, default to 'product')
     * @param  string|null $lang_id Search products specified by language id (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productFind'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductFind200Response
     */
    public function productFind($find_value, $find_where = 'name', $find_params = 'whole_words', $find_what = 'product', $lang_id = null, $store_id = null, string $contentType = self::contentTypes['productFind'][0])
    {
        list($response) = $this->productFindWithHttpInfo($find_value, $find_where, $find_params, $find_what, $lang_id, $store_id, $contentType);
        return $response;
    }

    /**
     * Operation productFindWithHttpInfo
     *
     * product.find
     *
     * @param  string $find_value Entity search that is specified by some value (required)
     * @param  string|null $find_where Entity search that is specified by the comma-separated unique fields (optional, default to 'name')
     * @param  string|null $find_params Entity search that is specified by comma-separated parameters (optional, default to 'whole_words')
     * @param  string|null $find_what Parameter&#39;s value specifies the entity that has to be found (optional, default to 'product')
     * @param  string|null $lang_id Search products specified by language id (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productFind'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductFind200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productFindWithHttpInfo($find_value, $find_where = 'name', $find_params = 'whole_words', $find_what = 'product', $lang_id = null, $store_id = null, string $contentType = self::contentTypes['productFind'][0])
    {
        $request = $this->productFindRequest($find_value, $find_where, $find_params, $find_what, $lang_id, $store_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProductFind200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProductFind200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProductFind200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ProductFind200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductFind200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productFindAsync
     *
     * product.find
     *
     * @param  string $find_value Entity search that is specified by some value (required)
     * @param  string|null $find_where Entity search that is specified by the comma-separated unique fields (optional, default to 'name')
     * @param  string|null $find_params Entity search that is specified by comma-separated parameters (optional, default to 'whole_words')
     * @param  string|null $find_what Parameter&#39;s value specifies the entity that has to be found (optional, default to 'product')
     * @param  string|null $lang_id Search products specified by language id (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productFind'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productFindAsync($find_value, $find_where = 'name', $find_params = 'whole_words', $find_what = 'product', $lang_id = null, $store_id = null, string $contentType = self::contentTypes['productFind'][0])
    {
        return $this->productFindAsyncWithHttpInfo($find_value, $find_where, $find_params, $find_what, $lang_id, $store_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productFindAsyncWithHttpInfo
     *
     * product.find
     *
     * @param  string $find_value Entity search that is specified by some value (required)
     * @param  string|null $find_where Entity search that is specified by the comma-separated unique fields (optional, default to 'name')
     * @param  string|null $find_params Entity search that is specified by comma-separated parameters (optional, default to 'whole_words')
     * @param  string|null $find_what Parameter&#39;s value specifies the entity that has to be found (optional, default to 'product')
     * @param  string|null $lang_id Search products specified by language id (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productFind'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productFindAsyncWithHttpInfo($find_value, $find_where = 'name', $find_params = 'whole_words', $find_what = 'product', $lang_id = null, $store_id = null, string $contentType = self::contentTypes['productFind'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProductFind200Response';
        $request = $this->productFindRequest($find_value, $find_where, $find_params, $find_what, $lang_id, $store_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productFind'
     *
     * @param  string $find_value Entity search that is specified by some value (required)
     * @param  string|null $find_where Entity search that is specified by the comma-separated unique fields (optional, default to 'name')
     * @param  string|null $find_params Entity search that is specified by comma-separated parameters (optional, default to 'whole_words')
     * @param  string|null $find_what Parameter&#39;s value specifies the entity that has to be found (optional, default to 'product')
     * @param  string|null $lang_id Search products specified by language id (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productFind'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productFindRequest($find_value, $find_where = 'name', $find_params = 'whole_words', $find_what = 'product', $lang_id = null, $store_id = null, string $contentType = self::contentTypes['productFind'][0])
    {

        // verify the required parameter 'find_value' is set
        if ($find_value === null || (is_array($find_value) && count($find_value) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $find_value when calling productFind'
            );
        }







        $resourcePath = '/product.find.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $find_value,
            'find_value', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $find_where,
            'find_where', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $find_params,
            'find_params', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $find_what,
            'find_what', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lang_id,
            'lang_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $store_id,
            'store_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productImageAdd
     *
     * product.image.add
     *
     * @param  \OpenAPI\Client\Model\ProductImageAdd $product_image_add product_image_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productImageAdd'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductImageAdd200Response
     */
    public function productImageAdd($product_image_add, string $contentType = self::contentTypes['productImageAdd'][0])
    {
        list($response) = $this->productImageAddWithHttpInfo($product_image_add, $contentType);
        return $response;
    }

    /**
     * Operation productImageAddWithHttpInfo
     *
     * product.image.add
     *
     * @param  \OpenAPI\Client\Model\ProductImageAdd $product_image_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productImageAdd'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductImageAdd200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productImageAddWithHttpInfo($product_image_add, string $contentType = self::contentTypes['productImageAdd'][0])
    {
        $request = $this->productImageAddRequest($product_image_add, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProductImageAdd200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProductImageAdd200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProductImageAdd200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ProductImageAdd200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductImageAdd200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productImageAddAsync
     *
     * product.image.add
     *
     * @param  \OpenAPI\Client\Model\ProductImageAdd $product_image_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productImageAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productImageAddAsync($product_image_add, string $contentType = self::contentTypes['productImageAdd'][0])
    {
        return $this->productImageAddAsyncWithHttpInfo($product_image_add, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productImageAddAsyncWithHttpInfo
     *
     * product.image.add
     *
     * @param  \OpenAPI\Client\Model\ProductImageAdd $product_image_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productImageAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productImageAddAsyncWithHttpInfo($product_image_add, string $contentType = self::contentTypes['productImageAdd'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProductImageAdd200Response';
        $request = $this->productImageAddRequest($product_image_add, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productImageAdd'
     *
     * @param  \OpenAPI\Client\Model\ProductImageAdd $product_image_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productImageAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productImageAddRequest($product_image_add, string $contentType = self::contentTypes['productImageAdd'][0])
    {

        // verify the required parameter 'product_image_add' is set
        if ($product_image_add === null || (is_array($product_image_add) && count($product_image_add) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_image_add when calling productImageAdd'
            );
        }


        $resourcePath = '/product.image.add.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($product_image_add)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($product_image_add));
            } else {
                $httpBody = $product_image_add;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productImageDelete
     *
     * product.image.delete
     *
     * @param  string $product_id Defines product id where the image should be deleted (required)
     * @param  string $id Entity id (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productImageDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AttributeDelete200Response
     */
    public function productImageDelete($product_id, $id, $store_id = null, string $contentType = self::contentTypes['productImageDelete'][0])
    {
        list($response) = $this->productImageDeleteWithHttpInfo($product_id, $id, $store_id, $contentType);
        return $response;
    }

    /**
     * Operation productImageDeleteWithHttpInfo
     *
     * product.image.delete
     *
     * @param  string $product_id Defines product id where the image should be deleted (required)
     * @param  string $id Entity id (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productImageDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AttributeDelete200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productImageDeleteWithHttpInfo($product_id, $id, $store_id = null, string $contentType = self::contentTypes['productImageDelete'][0])
    {
        $request = $this->productImageDeleteRequest($product_id, $id, $store_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AttributeDelete200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\AttributeDelete200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AttributeDelete200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\AttributeDelete200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AttributeDelete200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productImageDeleteAsync
     *
     * product.image.delete
     *
     * @param  string $product_id Defines product id where the image should be deleted (required)
     * @param  string $id Entity id (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productImageDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productImageDeleteAsync($product_id, $id, $store_id = null, string $contentType = self::contentTypes['productImageDelete'][0])
    {
        return $this->productImageDeleteAsyncWithHttpInfo($product_id, $id, $store_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productImageDeleteAsyncWithHttpInfo
     *
     * product.image.delete
     *
     * @param  string $product_id Defines product id where the image should be deleted (required)
     * @param  string $id Entity id (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productImageDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productImageDeleteAsyncWithHttpInfo($product_id, $id, $store_id = null, string $contentType = self::contentTypes['productImageDelete'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AttributeDelete200Response';
        $request = $this->productImageDeleteRequest($product_id, $id, $store_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productImageDelete'
     *
     * @param  string $product_id Defines product id where the image should be deleted (required)
     * @param  string $id Entity id (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productImageDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productImageDeleteRequest($product_id, $id, $store_id = null, string $contentType = self::contentTypes['productImageDelete'][0])
    {

        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_id when calling productImageDelete'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productImageDelete'
            );
        }



        $resourcePath = '/product.image.delete.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_id,
            'product_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $store_id,
            'store_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productImageUpdate
     *
     * product.image.update
     *
     * @param  string $product_id Defines product id where the image should be updated (required)
     * @param  string $id Defines image update specified by image id (required)
     * @param  string|null $variant_ids Defines product&#39;s variants ids (optional)
     * @param  string|null $image_name Defines image&#39;s name (optional)
     * @param  string|null $type Defines image&#39;s types that are specified by comma-separated list (optional, default to 'additional')
     * @param  string|null $label Defines alternative text that has to be attached to the picture (optional)
     * @param  int|null $position Defines images position in the list (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string|null $lang_id Language id (optional)
     * @param  bool|null $hidden Define is hide image (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productImageUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductImageUpdate200Response
     */
    public function productImageUpdate($product_id, $id, $variant_ids = null, $image_name = null, $type = 'additional', $label = null, $position = null, $store_id = null, $lang_id = null, $hidden = null, string $contentType = self::contentTypes['productImageUpdate'][0])
    {
        list($response) = $this->productImageUpdateWithHttpInfo($product_id, $id, $variant_ids, $image_name, $type, $label, $position, $store_id, $lang_id, $hidden, $contentType);
        return $response;
    }

    /**
     * Operation productImageUpdateWithHttpInfo
     *
     * product.image.update
     *
     * @param  string $product_id Defines product id where the image should be updated (required)
     * @param  string $id Defines image update specified by image id (required)
     * @param  string|null $variant_ids Defines product&#39;s variants ids (optional)
     * @param  string|null $image_name Defines image&#39;s name (optional)
     * @param  string|null $type Defines image&#39;s types that are specified by comma-separated list (optional, default to 'additional')
     * @param  string|null $label Defines alternative text that has to be attached to the picture (optional)
     * @param  int|null $position Defines images position in the list (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string|null $lang_id Language id (optional)
     * @param  bool|null $hidden Define is hide image (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productImageUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductImageUpdate200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productImageUpdateWithHttpInfo($product_id, $id, $variant_ids = null, $image_name = null, $type = 'additional', $label = null, $position = null, $store_id = null, $lang_id = null, $hidden = null, string $contentType = self::contentTypes['productImageUpdate'][0])
    {
        $request = $this->productImageUpdateRequest($product_id, $id, $variant_ids, $image_name, $type, $label, $position, $store_id, $lang_id, $hidden, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProductImageUpdate200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProductImageUpdate200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProductImageUpdate200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ProductImageUpdate200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductImageUpdate200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productImageUpdateAsync
     *
     * product.image.update
     *
     * @param  string $product_id Defines product id where the image should be updated (required)
     * @param  string $id Defines image update specified by image id (required)
     * @param  string|null $variant_ids Defines product&#39;s variants ids (optional)
     * @param  string|null $image_name Defines image&#39;s name (optional)
     * @param  string|null $type Defines image&#39;s types that are specified by comma-separated list (optional, default to 'additional')
     * @param  string|null $label Defines alternative text that has to be attached to the picture (optional)
     * @param  int|null $position Defines images position in the list (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string|null $lang_id Language id (optional)
     * @param  bool|null $hidden Define is hide image (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productImageUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productImageUpdateAsync($product_id, $id, $variant_ids = null, $image_name = null, $type = 'additional', $label = null, $position = null, $store_id = null, $lang_id = null, $hidden = null, string $contentType = self::contentTypes['productImageUpdate'][0])
    {
        return $this->productImageUpdateAsyncWithHttpInfo($product_id, $id, $variant_ids, $image_name, $type, $label, $position, $store_id, $lang_id, $hidden, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productImageUpdateAsyncWithHttpInfo
     *
     * product.image.update
     *
     * @param  string $product_id Defines product id where the image should be updated (required)
     * @param  string $id Defines image update specified by image id (required)
     * @param  string|null $variant_ids Defines product&#39;s variants ids (optional)
     * @param  string|null $image_name Defines image&#39;s name (optional)
     * @param  string|null $type Defines image&#39;s types that are specified by comma-separated list (optional, default to 'additional')
     * @param  string|null $label Defines alternative text that has to be attached to the picture (optional)
     * @param  int|null $position Defines images position in the list (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string|null $lang_id Language id (optional)
     * @param  bool|null $hidden Define is hide image (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productImageUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productImageUpdateAsyncWithHttpInfo($product_id, $id, $variant_ids = null, $image_name = null, $type = 'additional', $label = null, $position = null, $store_id = null, $lang_id = null, $hidden = null, string $contentType = self::contentTypes['productImageUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProductImageUpdate200Response';
        $request = $this->productImageUpdateRequest($product_id, $id, $variant_ids, $image_name, $type, $label, $position, $store_id, $lang_id, $hidden, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productImageUpdate'
     *
     * @param  string $product_id Defines product id where the image should be updated (required)
     * @param  string $id Defines image update specified by image id (required)
     * @param  string|null $variant_ids Defines product&#39;s variants ids (optional)
     * @param  string|null $image_name Defines image&#39;s name (optional)
     * @param  string|null $type Defines image&#39;s types that are specified by comma-separated list (optional, default to 'additional')
     * @param  string|null $label Defines alternative text that has to be attached to the picture (optional)
     * @param  int|null $position Defines images position in the list (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string|null $lang_id Language id (optional)
     * @param  bool|null $hidden Define is hide image (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productImageUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productImageUpdateRequest($product_id, $id, $variant_ids = null, $image_name = null, $type = 'additional', $label = null, $position = null, $store_id = null, $lang_id = null, $hidden = null, string $contentType = self::contentTypes['productImageUpdate'][0])
    {

        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_id when calling productImageUpdate'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productImageUpdate'
            );
        }










        $resourcePath = '/product.image.update.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_id,
            'product_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $variant_ids,
            'variant_ids', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_name,
            'image_name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $label,
            'label', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $position,
            'position', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $store_id,
            'store_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lang_id,
            'lang_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hidden,
            'hidden', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productInfo
     *
     * product.info
     *
     * @param  string $id Retrieves product&#39;s info specified by product id (required)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,name,description,price,categories_ids')
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $store_id Retrieves product info specified by store id (optional)
     * @param  string|null $lang_id Retrieves product info specified by language id (optional)
     * @param  string|null $currency_id Currency Id (optional)
     * @param  string|null $report_request_id Report request id (optional)
     * @param  bool|null $disable_report_cache Disable report cache for current request (optional, default to false)
     * @param  bool|null $use_latest_api_version Use the latest platform API version (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productInfo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductInfo200Response
     */
    public function productInfo($id, $params = 'id,name,description,price,categories_ids', $response_fields = null, $exclude = null, $store_id = null, $lang_id = null, $currency_id = null, $report_request_id = null, $disable_report_cache = false, $use_latest_api_version = false, string $contentType = self::contentTypes['productInfo'][0])
    {
        list($response) = $this->productInfoWithHttpInfo($id, $params, $response_fields, $exclude, $store_id, $lang_id, $currency_id, $report_request_id, $disable_report_cache, $use_latest_api_version, $contentType);
        return $response;
    }

    /**
     * Operation productInfoWithHttpInfo
     *
     * product.info
     *
     * @param  string $id Retrieves product&#39;s info specified by product id (required)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,name,description,price,categories_ids')
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $store_id Retrieves product info specified by store id (optional)
     * @param  string|null $lang_id Retrieves product info specified by language id (optional)
     * @param  string|null $currency_id Currency Id (optional)
     * @param  string|null $report_request_id Report request id (optional)
     * @param  bool|null $disable_report_cache Disable report cache for current request (optional, default to false)
     * @param  bool|null $use_latest_api_version Use the latest platform API version (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productInfo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductInfo200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productInfoWithHttpInfo($id, $params = 'id,name,description,price,categories_ids', $response_fields = null, $exclude = null, $store_id = null, $lang_id = null, $currency_id = null, $report_request_id = null, $disable_report_cache = false, $use_latest_api_version = false, string $contentType = self::contentTypes['productInfo'][0])
    {
        $request = $this->productInfoRequest($id, $params, $response_fields, $exclude, $store_id, $lang_id, $currency_id, $report_request_id, $disable_report_cache, $use_latest_api_version, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProductInfo200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProductInfo200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProductInfo200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ProductInfo200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductInfo200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productInfoAsync
     *
     * product.info
     *
     * @param  string $id Retrieves product&#39;s info specified by product id (required)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,name,description,price,categories_ids')
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $store_id Retrieves product info specified by store id (optional)
     * @param  string|null $lang_id Retrieves product info specified by language id (optional)
     * @param  string|null $currency_id Currency Id (optional)
     * @param  string|null $report_request_id Report request id (optional)
     * @param  bool|null $disable_report_cache Disable report cache for current request (optional, default to false)
     * @param  bool|null $use_latest_api_version Use the latest platform API version (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productInfoAsync($id, $params = 'id,name,description,price,categories_ids', $response_fields = null, $exclude = null, $store_id = null, $lang_id = null, $currency_id = null, $report_request_id = null, $disable_report_cache = false, $use_latest_api_version = false, string $contentType = self::contentTypes['productInfo'][0])
    {
        return $this->productInfoAsyncWithHttpInfo($id, $params, $response_fields, $exclude, $store_id, $lang_id, $currency_id, $report_request_id, $disable_report_cache, $use_latest_api_version, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productInfoAsyncWithHttpInfo
     *
     * product.info
     *
     * @param  string $id Retrieves product&#39;s info specified by product id (required)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,name,description,price,categories_ids')
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $store_id Retrieves product info specified by store id (optional)
     * @param  string|null $lang_id Retrieves product info specified by language id (optional)
     * @param  string|null $currency_id Currency Id (optional)
     * @param  string|null $report_request_id Report request id (optional)
     * @param  bool|null $disable_report_cache Disable report cache for current request (optional, default to false)
     * @param  bool|null $use_latest_api_version Use the latest platform API version (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productInfoAsyncWithHttpInfo($id, $params = 'id,name,description,price,categories_ids', $response_fields = null, $exclude = null, $store_id = null, $lang_id = null, $currency_id = null, $report_request_id = null, $disable_report_cache = false, $use_latest_api_version = false, string $contentType = self::contentTypes['productInfo'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProductInfo200Response';
        $request = $this->productInfoRequest($id, $params, $response_fields, $exclude, $store_id, $lang_id, $currency_id, $report_request_id, $disable_report_cache, $use_latest_api_version, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productInfo'
     *
     * @param  string $id Retrieves product&#39;s info specified by product id (required)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,name,description,price,categories_ids')
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $store_id Retrieves product info specified by store id (optional)
     * @param  string|null $lang_id Retrieves product info specified by language id (optional)
     * @param  string|null $currency_id Currency Id (optional)
     * @param  string|null $report_request_id Report request id (optional)
     * @param  bool|null $disable_report_cache Disable report cache for current request (optional, default to false)
     * @param  bool|null $use_latest_api_version Use the latest platform API version (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productInfoRequest($id, $params = 'id,name,description,price,categories_ids', $response_fields = null, $exclude = null, $store_id = null, $lang_id = null, $currency_id = null, $report_request_id = null, $disable_report_cache = false, $use_latest_api_version = false, string $contentType = self::contentTypes['productInfo'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productInfo'
            );
        }











        $resourcePath = '/product.info.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $params,
            'params', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $response_fields,
            'response_fields', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclude,
            'exclude', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $store_id,
            'store_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lang_id,
            'lang_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $currency_id,
            'currency_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $report_request_id,
            'report_request_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $disable_report_cache,
            'disable_report_cache', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $use_latest_api_version,
            'use_latest_api_version', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productList
     *
     * product.list
     *
     * @param  string|null $page_cursor Used to retrieve products via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,name,description,price,categories_ids')
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $category_id Retrieves products specified by category id (optional)
     * @param  string|null $created_from Retrieve entities from their creation date (optional)
     * @param  string|null $created_to Retrieve entities to their creation date (optional)
     * @param  string|null $modified_from Retrieve entities from their modification date (optional)
     * @param  string|null $modified_to Retrieve entities to their modification date (optional)
     * @param  bool|null $avail_view Specifies the set of visible/invisible products (optional)
     * @param  bool|null $avail_sale Specifies the set of available/not available products for sale (optional)
     * @param  string|null $store_id Retrieves products specified by store id (optional)
     * @param  string|null $lang_id Retrieves products specified by language id (optional)
     * @param  string|null $currency_id Currency Id (optional)
     * @param  string|null $product_ids Retrieves products specified by product ids (optional)
     * @param  string|null $since_id Retrieve entities starting from the specified id. (optional)
     * @param  string|null $report_request_id Report request id (optional)
     * @param  bool|null $disable_report_cache Disable report cache for current request (optional, default to false)
     * @param  string|null $sort_by Set field to sort by (optional, default to 'id')
     * @param  string|null $sort_direction Set sorting direction (optional, default to 'asc')
     * @param  string|null $sku Filter by product&#39;s sku (optional)
     * @param  bool|null $disable_cache Disable cache for current request (optional, default to false)
     * @param  string|null $brand_name Retrieves brands specified by brand name (optional)
     * @param  string[]|null $product_attributes Defines product attributes (optional)
     * @param  string|null $status Defines product&#39;s status (optional)
     * @param  string|null $type Defines products&#39;s type (optional)
     * @param  string|null $find_value Entity search that is specified by some value (optional)
     * @param  string|null $find_where Product search that is specified by field (optional)
     * @param  bool|null $use_latest_api_version Use the latest platform API version (optional, default to false)
     * @param  bool|null $return_global Determines the type of products to be returned. If set to &#39;true&#39;, only global products will be returned; if set to &#39;false&#39;, only local products will be returned. (optional, default to false)
     * @param  string|null $categories_ids Retrieves products specified by categories ids (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModelResponseProductList
     */
    public function productList($page_cursor = null, $start = 0, $count = 10, $params = 'id,name,description,price,categories_ids', $response_fields = null, $exclude = null, $category_id = null, $created_from = null, $created_to = null, $modified_from = null, $modified_to = null, $avail_view = null, $avail_sale = null, $store_id = null, $lang_id = null, $currency_id = null, $product_ids = null, $since_id = null, $report_request_id = null, $disable_report_cache = false, $sort_by = 'id', $sort_direction = 'asc', $sku = null, $disable_cache = false, $brand_name = null, $product_attributes = null, $status = null, $type = null, $find_value = null, $find_where = null, $use_latest_api_version = false, $return_global = false, $categories_ids = null, string $contentType = self::contentTypes['productList'][0])
    {
        list($response) = $this->productListWithHttpInfo($page_cursor, $start, $count, $params, $response_fields, $exclude, $category_id, $created_from, $created_to, $modified_from, $modified_to, $avail_view, $avail_sale, $store_id, $lang_id, $currency_id, $product_ids, $since_id, $report_request_id, $disable_report_cache, $sort_by, $sort_direction, $sku, $disable_cache, $brand_name, $product_attributes, $status, $type, $find_value, $find_where, $use_latest_api_version, $return_global, $categories_ids, $contentType);
        return $response;
    }

    /**
     * Operation productListWithHttpInfo
     *
     * product.list
     *
     * @param  string|null $page_cursor Used to retrieve products via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,name,description,price,categories_ids')
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $category_id Retrieves products specified by category id (optional)
     * @param  string|null $created_from Retrieve entities from their creation date (optional)
     * @param  string|null $created_to Retrieve entities to their creation date (optional)
     * @param  string|null $modified_from Retrieve entities from their modification date (optional)
     * @param  string|null $modified_to Retrieve entities to their modification date (optional)
     * @param  bool|null $avail_view Specifies the set of visible/invisible products (optional)
     * @param  bool|null $avail_sale Specifies the set of available/not available products for sale (optional)
     * @param  string|null $store_id Retrieves products specified by store id (optional)
     * @param  string|null $lang_id Retrieves products specified by language id (optional)
     * @param  string|null $currency_id Currency Id (optional)
     * @param  string|null $product_ids Retrieves products specified by product ids (optional)
     * @param  string|null $since_id Retrieve entities starting from the specified id. (optional)
     * @param  string|null $report_request_id Report request id (optional)
     * @param  bool|null $disable_report_cache Disable report cache for current request (optional, default to false)
     * @param  string|null $sort_by Set field to sort by (optional, default to 'id')
     * @param  string|null $sort_direction Set sorting direction (optional, default to 'asc')
     * @param  string|null $sku Filter by product&#39;s sku (optional)
     * @param  bool|null $disable_cache Disable cache for current request (optional, default to false)
     * @param  string|null $brand_name Retrieves brands specified by brand name (optional)
     * @param  string[]|null $product_attributes Defines product attributes (optional)
     * @param  string|null $status Defines product&#39;s status (optional)
     * @param  string|null $type Defines products&#39;s type (optional)
     * @param  string|null $find_value Entity search that is specified by some value (optional)
     * @param  string|null $find_where Product search that is specified by field (optional)
     * @param  bool|null $use_latest_api_version Use the latest platform API version (optional, default to false)
     * @param  bool|null $return_global Determines the type of products to be returned. If set to &#39;true&#39;, only global products will be returned; if set to &#39;false&#39;, only local products will be returned. (optional, default to false)
     * @param  string|null $categories_ids Retrieves products specified by categories ids (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModelResponseProductList, HTTP status code, HTTP response headers (array of strings)
     */
    public function productListWithHttpInfo($page_cursor = null, $start = 0, $count = 10, $params = 'id,name,description,price,categories_ids', $response_fields = null, $exclude = null, $category_id = null, $created_from = null, $created_to = null, $modified_from = null, $modified_to = null, $avail_view = null, $avail_sale = null, $store_id = null, $lang_id = null, $currency_id = null, $product_ids = null, $since_id = null, $report_request_id = null, $disable_report_cache = false, $sort_by = 'id', $sort_direction = 'asc', $sku = null, $disable_cache = false, $brand_name = null, $product_attributes = null, $status = null, $type = null, $find_value = null, $find_where = null, $use_latest_api_version = false, $return_global = false, $categories_ids = null, string $contentType = self::contentTypes['productList'][0])
    {
        $request = $this->productListRequest($page_cursor, $start, $count, $params, $response_fields, $exclude, $category_id, $created_from, $created_to, $modified_from, $modified_to, $avail_view, $avail_sale, $store_id, $lang_id, $currency_id, $product_ids, $since_id, $report_request_id, $disable_report_cache, $sort_by, $sort_direction, $sku, $disable_cache, $brand_name, $product_attributes, $status, $type, $find_value, $find_where, $use_latest_api_version, $return_global, $categories_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModelResponseProductList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ModelResponseProductList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModelResponseProductList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ModelResponseProductList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModelResponseProductList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productListAsync
     *
     * product.list
     *
     * @param  string|null $page_cursor Used to retrieve products via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,name,description,price,categories_ids')
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $category_id Retrieves products specified by category id (optional)
     * @param  string|null $created_from Retrieve entities from their creation date (optional)
     * @param  string|null $created_to Retrieve entities to their creation date (optional)
     * @param  string|null $modified_from Retrieve entities from their modification date (optional)
     * @param  string|null $modified_to Retrieve entities to their modification date (optional)
     * @param  bool|null $avail_view Specifies the set of visible/invisible products (optional)
     * @param  bool|null $avail_sale Specifies the set of available/not available products for sale (optional)
     * @param  string|null $store_id Retrieves products specified by store id (optional)
     * @param  string|null $lang_id Retrieves products specified by language id (optional)
     * @param  string|null $currency_id Currency Id (optional)
     * @param  string|null $product_ids Retrieves products specified by product ids (optional)
     * @param  string|null $since_id Retrieve entities starting from the specified id. (optional)
     * @param  string|null $report_request_id Report request id (optional)
     * @param  bool|null $disable_report_cache Disable report cache for current request (optional, default to false)
     * @param  string|null $sort_by Set field to sort by (optional, default to 'id')
     * @param  string|null $sort_direction Set sorting direction (optional, default to 'asc')
     * @param  string|null $sku Filter by product&#39;s sku (optional)
     * @param  bool|null $disable_cache Disable cache for current request (optional, default to false)
     * @param  string|null $brand_name Retrieves brands specified by brand name (optional)
     * @param  string[]|null $product_attributes Defines product attributes (optional)
     * @param  string|null $status Defines product&#39;s status (optional)
     * @param  string|null $type Defines products&#39;s type (optional)
     * @param  string|null $find_value Entity search that is specified by some value (optional)
     * @param  string|null $find_where Product search that is specified by field (optional)
     * @param  bool|null $use_latest_api_version Use the latest platform API version (optional, default to false)
     * @param  bool|null $return_global Determines the type of products to be returned. If set to &#39;true&#39;, only global products will be returned; if set to &#39;false&#39;, only local products will be returned. (optional, default to false)
     * @param  string|null $categories_ids Retrieves products specified by categories ids (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productListAsync($page_cursor = null, $start = 0, $count = 10, $params = 'id,name,description,price,categories_ids', $response_fields = null, $exclude = null, $category_id = null, $created_from = null, $created_to = null, $modified_from = null, $modified_to = null, $avail_view = null, $avail_sale = null, $store_id = null, $lang_id = null, $currency_id = null, $product_ids = null, $since_id = null, $report_request_id = null, $disable_report_cache = false, $sort_by = 'id', $sort_direction = 'asc', $sku = null, $disable_cache = false, $brand_name = null, $product_attributes = null, $status = null, $type = null, $find_value = null, $find_where = null, $use_latest_api_version = false, $return_global = false, $categories_ids = null, string $contentType = self::contentTypes['productList'][0])
    {
        return $this->productListAsyncWithHttpInfo($page_cursor, $start, $count, $params, $response_fields, $exclude, $category_id, $created_from, $created_to, $modified_from, $modified_to, $avail_view, $avail_sale, $store_id, $lang_id, $currency_id, $product_ids, $since_id, $report_request_id, $disable_report_cache, $sort_by, $sort_direction, $sku, $disable_cache, $brand_name, $product_attributes, $status, $type, $find_value, $find_where, $use_latest_api_version, $return_global, $categories_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productListAsyncWithHttpInfo
     *
     * product.list
     *
     * @param  string|null $page_cursor Used to retrieve products via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,name,description,price,categories_ids')
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $category_id Retrieves products specified by category id (optional)
     * @param  string|null $created_from Retrieve entities from their creation date (optional)
     * @param  string|null $created_to Retrieve entities to their creation date (optional)
     * @param  string|null $modified_from Retrieve entities from their modification date (optional)
     * @param  string|null $modified_to Retrieve entities to their modification date (optional)
     * @param  bool|null $avail_view Specifies the set of visible/invisible products (optional)
     * @param  bool|null $avail_sale Specifies the set of available/not available products for sale (optional)
     * @param  string|null $store_id Retrieves products specified by store id (optional)
     * @param  string|null $lang_id Retrieves products specified by language id (optional)
     * @param  string|null $currency_id Currency Id (optional)
     * @param  string|null $product_ids Retrieves products specified by product ids (optional)
     * @param  string|null $since_id Retrieve entities starting from the specified id. (optional)
     * @param  string|null $report_request_id Report request id (optional)
     * @param  bool|null $disable_report_cache Disable report cache for current request (optional, default to false)
     * @param  string|null $sort_by Set field to sort by (optional, default to 'id')
     * @param  string|null $sort_direction Set sorting direction (optional, default to 'asc')
     * @param  string|null $sku Filter by product&#39;s sku (optional)
     * @param  bool|null $disable_cache Disable cache for current request (optional, default to false)
     * @param  string|null $brand_name Retrieves brands specified by brand name (optional)
     * @param  string[]|null $product_attributes Defines product attributes (optional)
     * @param  string|null $status Defines product&#39;s status (optional)
     * @param  string|null $type Defines products&#39;s type (optional)
     * @param  string|null $find_value Entity search that is specified by some value (optional)
     * @param  string|null $find_where Product search that is specified by field (optional)
     * @param  bool|null $use_latest_api_version Use the latest platform API version (optional, default to false)
     * @param  bool|null $return_global Determines the type of products to be returned. If set to &#39;true&#39;, only global products will be returned; if set to &#39;false&#39;, only local products will be returned. (optional, default to false)
     * @param  string|null $categories_ids Retrieves products specified by categories ids (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productListAsyncWithHttpInfo($page_cursor = null, $start = 0, $count = 10, $params = 'id,name,description,price,categories_ids', $response_fields = null, $exclude = null, $category_id = null, $created_from = null, $created_to = null, $modified_from = null, $modified_to = null, $avail_view = null, $avail_sale = null, $store_id = null, $lang_id = null, $currency_id = null, $product_ids = null, $since_id = null, $report_request_id = null, $disable_report_cache = false, $sort_by = 'id', $sort_direction = 'asc', $sku = null, $disable_cache = false, $brand_name = null, $product_attributes = null, $status = null, $type = null, $find_value = null, $find_where = null, $use_latest_api_version = false, $return_global = false, $categories_ids = null, string $contentType = self::contentTypes['productList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ModelResponseProductList';
        $request = $this->productListRequest($page_cursor, $start, $count, $params, $response_fields, $exclude, $category_id, $created_from, $created_to, $modified_from, $modified_to, $avail_view, $avail_sale, $store_id, $lang_id, $currency_id, $product_ids, $since_id, $report_request_id, $disable_report_cache, $sort_by, $sort_direction, $sku, $disable_cache, $brand_name, $product_attributes, $status, $type, $find_value, $find_where, $use_latest_api_version, $return_global, $categories_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productList'
     *
     * @param  string|null $page_cursor Used to retrieve products via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,name,description,price,categories_ids')
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $category_id Retrieves products specified by category id (optional)
     * @param  string|null $created_from Retrieve entities from their creation date (optional)
     * @param  string|null $created_to Retrieve entities to their creation date (optional)
     * @param  string|null $modified_from Retrieve entities from their modification date (optional)
     * @param  string|null $modified_to Retrieve entities to their modification date (optional)
     * @param  bool|null $avail_view Specifies the set of visible/invisible products (optional)
     * @param  bool|null $avail_sale Specifies the set of available/not available products for sale (optional)
     * @param  string|null $store_id Retrieves products specified by store id (optional)
     * @param  string|null $lang_id Retrieves products specified by language id (optional)
     * @param  string|null $currency_id Currency Id (optional)
     * @param  string|null $product_ids Retrieves products specified by product ids (optional)
     * @param  string|null $since_id Retrieve entities starting from the specified id. (optional)
     * @param  string|null $report_request_id Report request id (optional)
     * @param  bool|null $disable_report_cache Disable report cache for current request (optional, default to false)
     * @param  string|null $sort_by Set field to sort by (optional, default to 'id')
     * @param  string|null $sort_direction Set sorting direction (optional, default to 'asc')
     * @param  string|null $sku Filter by product&#39;s sku (optional)
     * @param  bool|null $disable_cache Disable cache for current request (optional, default to false)
     * @param  string|null $brand_name Retrieves brands specified by brand name (optional)
     * @param  string[]|null $product_attributes Defines product attributes (optional)
     * @param  string|null $status Defines product&#39;s status (optional)
     * @param  string|null $type Defines products&#39;s type (optional)
     * @param  string|null $find_value Entity search that is specified by some value (optional)
     * @param  string|null $find_where Product search that is specified by field (optional)
     * @param  bool|null $use_latest_api_version Use the latest platform API version (optional, default to false)
     * @param  bool|null $return_global Determines the type of products to be returned. If set to &#39;true&#39;, only global products will be returned; if set to &#39;false&#39;, only local products will be returned. (optional, default to false)
     * @param  string|null $categories_ids Retrieves products specified by categories ids (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productListRequest($page_cursor = null, $start = 0, $count = 10, $params = 'id,name,description,price,categories_ids', $response_fields = null, $exclude = null, $category_id = null, $created_from = null, $created_to = null, $modified_from = null, $modified_to = null, $avail_view = null, $avail_sale = null, $store_id = null, $lang_id = null, $currency_id = null, $product_ids = null, $since_id = null, $report_request_id = null, $disable_report_cache = false, $sort_by = 'id', $sort_direction = 'asc', $sku = null, $disable_cache = false, $brand_name = null, $product_attributes = null, $status = null, $type = null, $find_value = null, $find_where = null, $use_latest_api_version = false, $return_global = false, $categories_ids = null, string $contentType = self::contentTypes['productList'][0])
    {



































        $resourcePath = '/product.list.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_cursor,
            'page_cursor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $params,
            'params', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $response_fields,
            'response_fields', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclude,
            'exclude', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category_id,
            'category_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_from,
            'created_from', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_to,
            'created_to', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_from,
            'modified_from', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_to,
            'modified_to', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $avail_view,
            'avail_view', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $avail_sale,
            'avail_sale', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $store_id,
            'store_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lang_id,
            'lang_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $currency_id,
            'currency_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_ids,
            'product_ids', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $since_id,
            'since_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $report_request_id,
            'report_request_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $disable_report_cache,
            'disable_report_cache', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_by,
            'sort_by', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_direction,
            'sort_direction', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sku,
            'sku', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $disable_cache,
            'disable_cache', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $brand_name,
            'brand_name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_attributes,
            'product_attributes', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $find_value,
            'find_value', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $find_where,
            'find_where', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $use_latest_api_version,
            'use_latest_api_version', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $return_global,
            'return_global', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $categories_ids,
            'categories_ids', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productManufacturerAdd
     *
     * product.manufacturer.add
     *
     * @param  string $product_id Defines products specified by product id (required)
     * @param  string $manufacturer Defines products manufacturer&#39;s name (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productManufacturerAdd'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductManufacturerAdd200Response
     */
    public function productManufacturerAdd($product_id, $manufacturer, $store_id = null, string $contentType = self::contentTypes['productManufacturerAdd'][0])
    {
        list($response) = $this->productManufacturerAddWithHttpInfo($product_id, $manufacturer, $store_id, $contentType);
        return $response;
    }

    /**
     * Operation productManufacturerAddWithHttpInfo
     *
     * product.manufacturer.add
     *
     * @param  string $product_id Defines products specified by product id (required)
     * @param  string $manufacturer Defines products manufacturer&#39;s name (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productManufacturerAdd'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductManufacturerAdd200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productManufacturerAddWithHttpInfo($product_id, $manufacturer, $store_id = null, string $contentType = self::contentTypes['productManufacturerAdd'][0])
    {
        $request = $this->productManufacturerAddRequest($product_id, $manufacturer, $store_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProductManufacturerAdd200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProductManufacturerAdd200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProductManufacturerAdd200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ProductManufacturerAdd200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductManufacturerAdd200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productManufacturerAddAsync
     *
     * product.manufacturer.add
     *
     * @param  string $product_id Defines products specified by product id (required)
     * @param  string $manufacturer Defines products manufacturer&#39;s name (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productManufacturerAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productManufacturerAddAsync($product_id, $manufacturer, $store_id = null, string $contentType = self::contentTypes['productManufacturerAdd'][0])
    {
        return $this->productManufacturerAddAsyncWithHttpInfo($product_id, $manufacturer, $store_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productManufacturerAddAsyncWithHttpInfo
     *
     * product.manufacturer.add
     *
     * @param  string $product_id Defines products specified by product id (required)
     * @param  string $manufacturer Defines products manufacturer&#39;s name (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productManufacturerAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productManufacturerAddAsyncWithHttpInfo($product_id, $manufacturer, $store_id = null, string $contentType = self::contentTypes['productManufacturerAdd'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProductManufacturerAdd200Response';
        $request = $this->productManufacturerAddRequest($product_id, $manufacturer, $store_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productManufacturerAdd'
     *
     * @param  string $product_id Defines products specified by product id (required)
     * @param  string $manufacturer Defines products manufacturer&#39;s name (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productManufacturerAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productManufacturerAddRequest($product_id, $manufacturer, $store_id = null, string $contentType = self::contentTypes['productManufacturerAdd'][0])
    {

        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_id when calling productManufacturerAdd'
            );
        }

        // verify the required parameter 'manufacturer' is set
        if ($manufacturer === null || (is_array($manufacturer) && count($manufacturer) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $manufacturer when calling productManufacturerAdd'
            );
        }



        $resourcePath = '/product.manufacturer.add.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_id,
            'product_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $manufacturer,
            'manufacturer', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $store_id,
            'store_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productOptionAdd
     *
     * product.option.add
     *
     * @param  \OpenAPI\Client\Model\ProductOptionAdd $product_option_add product_option_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionAdd'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductOptionAdd200Response
     */
    public function productOptionAdd($product_option_add, string $contentType = self::contentTypes['productOptionAdd'][0])
    {
        list($response) = $this->productOptionAddWithHttpInfo($product_option_add, $contentType);
        return $response;
    }

    /**
     * Operation productOptionAddWithHttpInfo
     *
     * product.option.add
     *
     * @param  \OpenAPI\Client\Model\ProductOptionAdd $product_option_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionAdd'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductOptionAdd200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productOptionAddWithHttpInfo($product_option_add, string $contentType = self::contentTypes['productOptionAdd'][0])
    {
        $request = $this->productOptionAddRequest($product_option_add, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProductOptionAdd200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProductOptionAdd200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProductOptionAdd200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ProductOptionAdd200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductOptionAdd200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productOptionAddAsync
     *
     * product.option.add
     *
     * @param  \OpenAPI\Client\Model\ProductOptionAdd $product_option_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productOptionAddAsync($product_option_add, string $contentType = self::contentTypes['productOptionAdd'][0])
    {
        return $this->productOptionAddAsyncWithHttpInfo($product_option_add, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productOptionAddAsyncWithHttpInfo
     *
     * product.option.add
     *
     * @param  \OpenAPI\Client\Model\ProductOptionAdd $product_option_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productOptionAddAsyncWithHttpInfo($product_option_add, string $contentType = self::contentTypes['productOptionAdd'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProductOptionAdd200Response';
        $request = $this->productOptionAddRequest($product_option_add, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productOptionAdd'
     *
     * @param  \OpenAPI\Client\Model\ProductOptionAdd $product_option_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productOptionAddRequest($product_option_add, string $contentType = self::contentTypes['productOptionAdd'][0])
    {

        // verify the required parameter 'product_option_add' is set
        if ($product_option_add === null || (is_array($product_option_add) && count($product_option_add) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_option_add when calling productOptionAdd'
            );
        }


        $resourcePath = '/product.option.add.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($product_option_add)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($product_option_add));
            } else {
                $httpBody = $product_option_add;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productOptionAssign
     *
     * product.option.assign
     *
     * @param  string $product_id Defines product id where the option should be assigned (required)
     * @param  string $option_id Defines option id which has to be assigned (required)
     * @param  bool|null $required Defines if the option is required (optional, default to false)
     * @param  int|null $sort_order Sort number in the list (optional, default to 0)
     * @param  string|null $option_values Defines option values that has to be assigned (optional)
     * @param  bool|null $clear_cache Is cache clear required (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionAssign'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductOptionAssign200Response
     */
    public function productOptionAssign($product_id, $option_id, $required = false, $sort_order = 0, $option_values = null, $clear_cache = true, string $contentType = self::contentTypes['productOptionAssign'][0])
    {
        list($response) = $this->productOptionAssignWithHttpInfo($product_id, $option_id, $required, $sort_order, $option_values, $clear_cache, $contentType);
        return $response;
    }

    /**
     * Operation productOptionAssignWithHttpInfo
     *
     * product.option.assign
     *
     * @param  string $product_id Defines product id where the option should be assigned (required)
     * @param  string $option_id Defines option id which has to be assigned (required)
     * @param  bool|null $required Defines if the option is required (optional, default to false)
     * @param  int|null $sort_order Sort number in the list (optional, default to 0)
     * @param  string|null $option_values Defines option values that has to be assigned (optional)
     * @param  bool|null $clear_cache Is cache clear required (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionAssign'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductOptionAssign200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productOptionAssignWithHttpInfo($product_id, $option_id, $required = false, $sort_order = 0, $option_values = null, $clear_cache = true, string $contentType = self::contentTypes['productOptionAssign'][0])
    {
        $request = $this->productOptionAssignRequest($product_id, $option_id, $required, $sort_order, $option_values, $clear_cache, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProductOptionAssign200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProductOptionAssign200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProductOptionAssign200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ProductOptionAssign200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductOptionAssign200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productOptionAssignAsync
     *
     * product.option.assign
     *
     * @param  string $product_id Defines product id where the option should be assigned (required)
     * @param  string $option_id Defines option id which has to be assigned (required)
     * @param  bool|null $required Defines if the option is required (optional, default to false)
     * @param  int|null $sort_order Sort number in the list (optional, default to 0)
     * @param  string|null $option_values Defines option values that has to be assigned (optional)
     * @param  bool|null $clear_cache Is cache clear required (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionAssign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productOptionAssignAsync($product_id, $option_id, $required = false, $sort_order = 0, $option_values = null, $clear_cache = true, string $contentType = self::contentTypes['productOptionAssign'][0])
    {
        return $this->productOptionAssignAsyncWithHttpInfo($product_id, $option_id, $required, $sort_order, $option_values, $clear_cache, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productOptionAssignAsyncWithHttpInfo
     *
     * product.option.assign
     *
     * @param  string $product_id Defines product id where the option should be assigned (required)
     * @param  string $option_id Defines option id which has to be assigned (required)
     * @param  bool|null $required Defines if the option is required (optional, default to false)
     * @param  int|null $sort_order Sort number in the list (optional, default to 0)
     * @param  string|null $option_values Defines option values that has to be assigned (optional)
     * @param  bool|null $clear_cache Is cache clear required (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionAssign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productOptionAssignAsyncWithHttpInfo($product_id, $option_id, $required = false, $sort_order = 0, $option_values = null, $clear_cache = true, string $contentType = self::contentTypes['productOptionAssign'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProductOptionAssign200Response';
        $request = $this->productOptionAssignRequest($product_id, $option_id, $required, $sort_order, $option_values, $clear_cache, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productOptionAssign'
     *
     * @param  string $product_id Defines product id where the option should be assigned (required)
     * @param  string $option_id Defines option id which has to be assigned (required)
     * @param  bool|null $required Defines if the option is required (optional, default to false)
     * @param  int|null $sort_order Sort number in the list (optional, default to 0)
     * @param  string|null $option_values Defines option values that has to be assigned (optional)
     * @param  bool|null $clear_cache Is cache clear required (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionAssign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productOptionAssignRequest($product_id, $option_id, $required = false, $sort_order = 0, $option_values = null, $clear_cache = true, string $contentType = self::contentTypes['productOptionAssign'][0])
    {

        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_id when calling productOptionAssign'
            );
        }

        // verify the required parameter 'option_id' is set
        if ($option_id === null || (is_array($option_id) && count($option_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_id when calling productOptionAssign'
            );
        }






        $resourcePath = '/product.option.assign.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_id,
            'product_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $option_id,
            'option_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $required,
            'required', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_order,
            'sort_order', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $option_values,
            'option_values', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $clear_cache,
            'clear_cache', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productOptionDelete
     *
     * product.option.delete
     *
     * @param  string $option_id Defines option id that should be deleted (required)
     * @param  string $product_id Defines product id where the option should be deleted (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AttributeDelete200Response
     */
    public function productOptionDelete($option_id, $product_id, $store_id = null, string $contentType = self::contentTypes['productOptionDelete'][0])
    {
        list($response) = $this->productOptionDeleteWithHttpInfo($option_id, $product_id, $store_id, $contentType);
        return $response;
    }

    /**
     * Operation productOptionDeleteWithHttpInfo
     *
     * product.option.delete
     *
     * @param  string $option_id Defines option id that should be deleted (required)
     * @param  string $product_id Defines product id where the option should be deleted (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AttributeDelete200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productOptionDeleteWithHttpInfo($option_id, $product_id, $store_id = null, string $contentType = self::contentTypes['productOptionDelete'][0])
    {
        $request = $this->productOptionDeleteRequest($option_id, $product_id, $store_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AttributeDelete200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\AttributeDelete200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AttributeDelete200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\AttributeDelete200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AttributeDelete200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productOptionDeleteAsync
     *
     * product.option.delete
     *
     * @param  string $option_id Defines option id that should be deleted (required)
     * @param  string $product_id Defines product id where the option should be deleted (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productOptionDeleteAsync($option_id, $product_id, $store_id = null, string $contentType = self::contentTypes['productOptionDelete'][0])
    {
        return $this->productOptionDeleteAsyncWithHttpInfo($option_id, $product_id, $store_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productOptionDeleteAsyncWithHttpInfo
     *
     * product.option.delete
     *
     * @param  string $option_id Defines option id that should be deleted (required)
     * @param  string $product_id Defines product id where the option should be deleted (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productOptionDeleteAsyncWithHttpInfo($option_id, $product_id, $store_id = null, string $contentType = self::contentTypes['productOptionDelete'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AttributeDelete200Response';
        $request = $this->productOptionDeleteRequest($option_id, $product_id, $store_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productOptionDelete'
     *
     * @param  string $option_id Defines option id that should be deleted (required)
     * @param  string $product_id Defines product id where the option should be deleted (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productOptionDeleteRequest($option_id, $product_id, $store_id = null, string $contentType = self::contentTypes['productOptionDelete'][0])
    {

        // verify the required parameter 'option_id' is set
        if ($option_id === null || (is_array($option_id) && count($option_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_id when calling productOptionDelete'
            );
        }

        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_id when calling productOptionDelete'
            );
        }



        $resourcePath = '/product.option.delete.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $option_id,
            'option_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_id,
            'product_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $store_id,
            'store_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productOptionList
     *
     * product.option.list
     *
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,name,description')
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string|null $product_id Retrieves products&#39; options specified by product id (optional)
     * @param  string|null $lang_id Language id (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModelResponseProductOptionList
     */
    public function productOptionList($start = 0, $count = 10, $params = 'id,name,description', $exclude = null, $response_fields = null, $product_id = null, $lang_id = null, $store_id = null, string $contentType = self::contentTypes['productOptionList'][0])
    {
        list($response) = $this->productOptionListWithHttpInfo($start, $count, $params, $exclude, $response_fields, $product_id, $lang_id, $store_id, $contentType);
        return $response;
    }

    /**
     * Operation productOptionListWithHttpInfo
     *
     * product.option.list
     *
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,name,description')
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string|null $product_id Retrieves products&#39; options specified by product id (optional)
     * @param  string|null $lang_id Language id (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModelResponseProductOptionList, HTTP status code, HTTP response headers (array of strings)
     */
    public function productOptionListWithHttpInfo($start = 0, $count = 10, $params = 'id,name,description', $exclude = null, $response_fields = null, $product_id = null, $lang_id = null, $store_id = null, string $contentType = self::contentTypes['productOptionList'][0])
    {
        $request = $this->productOptionListRequest($start, $count, $params, $exclude, $response_fields, $product_id, $lang_id, $store_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModelResponseProductOptionList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ModelResponseProductOptionList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModelResponseProductOptionList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ModelResponseProductOptionList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModelResponseProductOptionList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productOptionListAsync
     *
     * product.option.list
     *
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,name,description')
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string|null $product_id Retrieves products&#39; options specified by product id (optional)
     * @param  string|null $lang_id Language id (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productOptionListAsync($start = 0, $count = 10, $params = 'id,name,description', $exclude = null, $response_fields = null, $product_id = null, $lang_id = null, $store_id = null, string $contentType = self::contentTypes['productOptionList'][0])
    {
        return $this->productOptionListAsyncWithHttpInfo($start, $count, $params, $exclude, $response_fields, $product_id, $lang_id, $store_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productOptionListAsyncWithHttpInfo
     *
     * product.option.list
     *
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,name,description')
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string|null $product_id Retrieves products&#39; options specified by product id (optional)
     * @param  string|null $lang_id Language id (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productOptionListAsyncWithHttpInfo($start = 0, $count = 10, $params = 'id,name,description', $exclude = null, $response_fields = null, $product_id = null, $lang_id = null, $store_id = null, string $contentType = self::contentTypes['productOptionList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ModelResponseProductOptionList';
        $request = $this->productOptionListRequest($start, $count, $params, $exclude, $response_fields, $product_id, $lang_id, $store_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productOptionList'
     *
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,name,description')
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string|null $product_id Retrieves products&#39; options specified by product id (optional)
     * @param  string|null $lang_id Language id (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productOptionListRequest($start = 0, $count = 10, $params = 'id,name,description', $exclude = null, $response_fields = null, $product_id = null, $lang_id = null, $store_id = null, string $contentType = self::contentTypes['productOptionList'][0])
    {










        $resourcePath = '/product.option.list.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $params,
            'params', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclude,
            'exclude', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $response_fields,
            'response_fields', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_id,
            'product_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lang_id,
            'lang_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $store_id,
            'store_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productOptionValueAdd
     *
     * product.option.value.add
     *
     * @param  string $product_id Defines product id where the option value should be added (required)
     * @param  string $option_id Defines option id where the value has to be added (required)
     * @param  string|null $option_value Defines option value that has to be added (optional)
     * @param  int|null $sort_order Sort number in the list (optional, default to 0)
     * @param  string|null $display_value Defines the value that will be displayed for the option value (optional)
     * @param  bool|null $is_default Defines as a default (optional)
     * @param  bool|null $clear_cache Is cache clear required (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionValueAdd'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductOptionValueAdd200Response
     */
    public function productOptionValueAdd($product_id, $option_id, $option_value = null, $sort_order = 0, $display_value = null, $is_default = null, $clear_cache = true, string $contentType = self::contentTypes['productOptionValueAdd'][0])
    {
        list($response) = $this->productOptionValueAddWithHttpInfo($product_id, $option_id, $option_value, $sort_order, $display_value, $is_default, $clear_cache, $contentType);
        return $response;
    }

    /**
     * Operation productOptionValueAddWithHttpInfo
     *
     * product.option.value.add
     *
     * @param  string $product_id Defines product id where the option value should be added (required)
     * @param  string $option_id Defines option id where the value has to be added (required)
     * @param  string|null $option_value Defines option value that has to be added (optional)
     * @param  int|null $sort_order Sort number in the list (optional, default to 0)
     * @param  string|null $display_value Defines the value that will be displayed for the option value (optional)
     * @param  bool|null $is_default Defines as a default (optional)
     * @param  bool|null $clear_cache Is cache clear required (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionValueAdd'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductOptionValueAdd200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productOptionValueAddWithHttpInfo($product_id, $option_id, $option_value = null, $sort_order = 0, $display_value = null, $is_default = null, $clear_cache = true, string $contentType = self::contentTypes['productOptionValueAdd'][0])
    {
        $request = $this->productOptionValueAddRequest($product_id, $option_id, $option_value, $sort_order, $display_value, $is_default, $clear_cache, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProductOptionValueAdd200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProductOptionValueAdd200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProductOptionValueAdd200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ProductOptionValueAdd200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductOptionValueAdd200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productOptionValueAddAsync
     *
     * product.option.value.add
     *
     * @param  string $product_id Defines product id where the option value should be added (required)
     * @param  string $option_id Defines option id where the value has to be added (required)
     * @param  string|null $option_value Defines option value that has to be added (optional)
     * @param  int|null $sort_order Sort number in the list (optional, default to 0)
     * @param  string|null $display_value Defines the value that will be displayed for the option value (optional)
     * @param  bool|null $is_default Defines as a default (optional)
     * @param  bool|null $clear_cache Is cache clear required (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionValueAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productOptionValueAddAsync($product_id, $option_id, $option_value = null, $sort_order = 0, $display_value = null, $is_default = null, $clear_cache = true, string $contentType = self::contentTypes['productOptionValueAdd'][0])
    {
        return $this->productOptionValueAddAsyncWithHttpInfo($product_id, $option_id, $option_value, $sort_order, $display_value, $is_default, $clear_cache, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productOptionValueAddAsyncWithHttpInfo
     *
     * product.option.value.add
     *
     * @param  string $product_id Defines product id where the option value should be added (required)
     * @param  string $option_id Defines option id where the value has to be added (required)
     * @param  string|null $option_value Defines option value that has to be added (optional)
     * @param  int|null $sort_order Sort number in the list (optional, default to 0)
     * @param  string|null $display_value Defines the value that will be displayed for the option value (optional)
     * @param  bool|null $is_default Defines as a default (optional)
     * @param  bool|null $clear_cache Is cache clear required (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionValueAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productOptionValueAddAsyncWithHttpInfo($product_id, $option_id, $option_value = null, $sort_order = 0, $display_value = null, $is_default = null, $clear_cache = true, string $contentType = self::contentTypes['productOptionValueAdd'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProductOptionValueAdd200Response';
        $request = $this->productOptionValueAddRequest($product_id, $option_id, $option_value, $sort_order, $display_value, $is_default, $clear_cache, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productOptionValueAdd'
     *
     * @param  string $product_id Defines product id where the option value should be added (required)
     * @param  string $option_id Defines option id where the value has to be added (required)
     * @param  string|null $option_value Defines option value that has to be added (optional)
     * @param  int|null $sort_order Sort number in the list (optional, default to 0)
     * @param  string|null $display_value Defines the value that will be displayed for the option value (optional)
     * @param  bool|null $is_default Defines as a default (optional)
     * @param  bool|null $clear_cache Is cache clear required (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionValueAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productOptionValueAddRequest($product_id, $option_id, $option_value = null, $sort_order = 0, $display_value = null, $is_default = null, $clear_cache = true, string $contentType = self::contentTypes['productOptionValueAdd'][0])
    {

        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_id when calling productOptionValueAdd'
            );
        }

        // verify the required parameter 'option_id' is set
        if ($option_id === null || (is_array($option_id) && count($option_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_id when calling productOptionValueAdd'
            );
        }







        $resourcePath = '/product.option.value.add.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_id,
            'product_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $option_id,
            'option_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $option_value,
            'option_value', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_order,
            'sort_order', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $display_value,
            'display_value', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_default,
            'is_default', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $clear_cache,
            'clear_cache', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productOptionValueAssign
     *
     * product.option.value.assign
     *
     * @param  int $product_option_id Defines product&#39;s option id where the value has to be assigned (required)
     * @param  string $option_value_id Defines value id that has to be assigned (required)
     * @param  bool|null $clear_cache Is cache clear required (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionValueAssign'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductOptionValueAssign200Response
     */
    public function productOptionValueAssign($product_option_id, $option_value_id, $clear_cache = true, string $contentType = self::contentTypes['productOptionValueAssign'][0])
    {
        list($response) = $this->productOptionValueAssignWithHttpInfo($product_option_id, $option_value_id, $clear_cache, $contentType);
        return $response;
    }

    /**
     * Operation productOptionValueAssignWithHttpInfo
     *
     * product.option.value.assign
     *
     * @param  int $product_option_id Defines product&#39;s option id where the value has to be assigned (required)
     * @param  string $option_value_id Defines value id that has to be assigned (required)
     * @param  bool|null $clear_cache Is cache clear required (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionValueAssign'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductOptionValueAssign200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productOptionValueAssignWithHttpInfo($product_option_id, $option_value_id, $clear_cache = true, string $contentType = self::contentTypes['productOptionValueAssign'][0])
    {
        $request = $this->productOptionValueAssignRequest($product_option_id, $option_value_id, $clear_cache, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProductOptionValueAssign200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProductOptionValueAssign200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProductOptionValueAssign200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ProductOptionValueAssign200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductOptionValueAssign200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productOptionValueAssignAsync
     *
     * product.option.value.assign
     *
     * @param  int $product_option_id Defines product&#39;s option id where the value has to be assigned (required)
     * @param  string $option_value_id Defines value id that has to be assigned (required)
     * @param  bool|null $clear_cache Is cache clear required (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionValueAssign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productOptionValueAssignAsync($product_option_id, $option_value_id, $clear_cache = true, string $contentType = self::contentTypes['productOptionValueAssign'][0])
    {
        return $this->productOptionValueAssignAsyncWithHttpInfo($product_option_id, $option_value_id, $clear_cache, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productOptionValueAssignAsyncWithHttpInfo
     *
     * product.option.value.assign
     *
     * @param  int $product_option_id Defines product&#39;s option id where the value has to be assigned (required)
     * @param  string $option_value_id Defines value id that has to be assigned (required)
     * @param  bool|null $clear_cache Is cache clear required (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionValueAssign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productOptionValueAssignAsyncWithHttpInfo($product_option_id, $option_value_id, $clear_cache = true, string $contentType = self::contentTypes['productOptionValueAssign'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProductOptionValueAssign200Response';
        $request = $this->productOptionValueAssignRequest($product_option_id, $option_value_id, $clear_cache, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productOptionValueAssign'
     *
     * @param  int $product_option_id Defines product&#39;s option id where the value has to be assigned (required)
     * @param  string $option_value_id Defines value id that has to be assigned (required)
     * @param  bool|null $clear_cache Is cache clear required (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionValueAssign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productOptionValueAssignRequest($product_option_id, $option_value_id, $clear_cache = true, string $contentType = self::contentTypes['productOptionValueAssign'][0])
    {

        // verify the required parameter 'product_option_id' is set
        if ($product_option_id === null || (is_array($product_option_id) && count($product_option_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_option_id when calling productOptionValueAssign'
            );
        }

        // verify the required parameter 'option_value_id' is set
        if ($option_value_id === null || (is_array($option_value_id) && count($option_value_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_value_id when calling productOptionValueAssign'
            );
        }



        $resourcePath = '/product.option.value.assign.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_option_id,
            'product_option_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $option_value_id,
            'option_value_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $clear_cache,
            'clear_cache', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productOptionValueDelete
     *
     * product.option.value.delete
     *
     * @param  string $option_id Defines option id where the value should be deleted (required)
     * @param  string $option_value_id Defines option value id that should be deleted (required)
     * @param  string $product_id Defines product id where the option value should be deleted (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionValueDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AttributeDelete200Response
     */
    public function productOptionValueDelete($option_id, $option_value_id, $product_id, $store_id = null, string $contentType = self::contentTypes['productOptionValueDelete'][0])
    {
        list($response) = $this->productOptionValueDeleteWithHttpInfo($option_id, $option_value_id, $product_id, $store_id, $contentType);
        return $response;
    }

    /**
     * Operation productOptionValueDeleteWithHttpInfo
     *
     * product.option.value.delete
     *
     * @param  string $option_id Defines option id where the value should be deleted (required)
     * @param  string $option_value_id Defines option value id that should be deleted (required)
     * @param  string $product_id Defines product id where the option value should be deleted (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionValueDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AttributeDelete200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productOptionValueDeleteWithHttpInfo($option_id, $option_value_id, $product_id, $store_id = null, string $contentType = self::contentTypes['productOptionValueDelete'][0])
    {
        $request = $this->productOptionValueDeleteRequest($option_id, $option_value_id, $product_id, $store_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AttributeDelete200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\AttributeDelete200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AttributeDelete200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\AttributeDelete200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AttributeDelete200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productOptionValueDeleteAsync
     *
     * product.option.value.delete
     *
     * @param  string $option_id Defines option id where the value should be deleted (required)
     * @param  string $option_value_id Defines option value id that should be deleted (required)
     * @param  string $product_id Defines product id where the option value should be deleted (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionValueDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productOptionValueDeleteAsync($option_id, $option_value_id, $product_id, $store_id = null, string $contentType = self::contentTypes['productOptionValueDelete'][0])
    {
        return $this->productOptionValueDeleteAsyncWithHttpInfo($option_id, $option_value_id, $product_id, $store_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productOptionValueDeleteAsyncWithHttpInfo
     *
     * product.option.value.delete
     *
     * @param  string $option_id Defines option id where the value should be deleted (required)
     * @param  string $option_value_id Defines option value id that should be deleted (required)
     * @param  string $product_id Defines product id where the option value should be deleted (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionValueDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productOptionValueDeleteAsyncWithHttpInfo($option_id, $option_value_id, $product_id, $store_id = null, string $contentType = self::contentTypes['productOptionValueDelete'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AttributeDelete200Response';
        $request = $this->productOptionValueDeleteRequest($option_id, $option_value_id, $product_id, $store_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productOptionValueDelete'
     *
     * @param  string $option_id Defines option id where the value should be deleted (required)
     * @param  string $option_value_id Defines option value id that should be deleted (required)
     * @param  string $product_id Defines product id where the option value should be deleted (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionValueDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productOptionValueDeleteRequest($option_id, $option_value_id, $product_id, $store_id = null, string $contentType = self::contentTypes['productOptionValueDelete'][0])
    {

        // verify the required parameter 'option_id' is set
        if ($option_id === null || (is_array($option_id) && count($option_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_id when calling productOptionValueDelete'
            );
        }

        // verify the required parameter 'option_value_id' is set
        if ($option_value_id === null || (is_array($option_value_id) && count($option_value_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_value_id when calling productOptionValueDelete'
            );
        }

        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_id when calling productOptionValueDelete'
            );
        }



        $resourcePath = '/product.option.value.delete.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $option_id,
            'option_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $option_value_id,
            'option_value_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_id,
            'product_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $store_id,
            'store_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productOptionValueUpdate
     *
     * product.option.value.update
     *
     * @param  string $product_id Defines product id where the option value should be updated (required)
     * @param  string $option_id Defines option id where the value has to be updated (required)
     * @param  string $option_value_id Defines value id that has to be assigned (required)
     * @param  string|null $option_value Defines option value that has to be added (optional)
     * @param  float|null $price Defines new product option price (optional)
     * @param  float|null $quantity Defines new products&#39; options quantity (optional)
     * @param  string|null $display_value Defines the value that will be displayed for the option value (optional)
     * @param  bool|null $clear_cache Is cache clear required (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionValueUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AccountConfigUpdate200Response
     */
    public function productOptionValueUpdate($product_id, $option_id, $option_value_id, $option_value = null, $price = null, $quantity = null, $display_value = null, $clear_cache = true, string $contentType = self::contentTypes['productOptionValueUpdate'][0])
    {
        list($response) = $this->productOptionValueUpdateWithHttpInfo($product_id, $option_id, $option_value_id, $option_value, $price, $quantity, $display_value, $clear_cache, $contentType);
        return $response;
    }

    /**
     * Operation productOptionValueUpdateWithHttpInfo
     *
     * product.option.value.update
     *
     * @param  string $product_id Defines product id where the option value should be updated (required)
     * @param  string $option_id Defines option id where the value has to be updated (required)
     * @param  string $option_value_id Defines value id that has to be assigned (required)
     * @param  string|null $option_value Defines option value that has to be added (optional)
     * @param  float|null $price Defines new product option price (optional)
     * @param  float|null $quantity Defines new products&#39; options quantity (optional)
     * @param  string|null $display_value Defines the value that will be displayed for the option value (optional)
     * @param  bool|null $clear_cache Is cache clear required (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionValueUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AccountConfigUpdate200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productOptionValueUpdateWithHttpInfo($product_id, $option_id, $option_value_id, $option_value = null, $price = null, $quantity = null, $display_value = null, $clear_cache = true, string $contentType = self::contentTypes['productOptionValueUpdate'][0])
    {
        $request = $this->productOptionValueUpdateRequest($product_id, $option_id, $option_value_id, $option_value, $price, $quantity, $display_value, $clear_cache, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AccountConfigUpdate200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\AccountConfigUpdate200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AccountConfigUpdate200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\AccountConfigUpdate200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AccountConfigUpdate200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productOptionValueUpdateAsync
     *
     * product.option.value.update
     *
     * @param  string $product_id Defines product id where the option value should be updated (required)
     * @param  string $option_id Defines option id where the value has to be updated (required)
     * @param  string $option_value_id Defines value id that has to be assigned (required)
     * @param  string|null $option_value Defines option value that has to be added (optional)
     * @param  float|null $price Defines new product option price (optional)
     * @param  float|null $quantity Defines new products&#39; options quantity (optional)
     * @param  string|null $display_value Defines the value that will be displayed for the option value (optional)
     * @param  bool|null $clear_cache Is cache clear required (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionValueUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productOptionValueUpdateAsync($product_id, $option_id, $option_value_id, $option_value = null, $price = null, $quantity = null, $display_value = null, $clear_cache = true, string $contentType = self::contentTypes['productOptionValueUpdate'][0])
    {
        return $this->productOptionValueUpdateAsyncWithHttpInfo($product_id, $option_id, $option_value_id, $option_value, $price, $quantity, $display_value, $clear_cache, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productOptionValueUpdateAsyncWithHttpInfo
     *
     * product.option.value.update
     *
     * @param  string $product_id Defines product id where the option value should be updated (required)
     * @param  string $option_id Defines option id where the value has to be updated (required)
     * @param  string $option_value_id Defines value id that has to be assigned (required)
     * @param  string|null $option_value Defines option value that has to be added (optional)
     * @param  float|null $price Defines new product option price (optional)
     * @param  float|null $quantity Defines new products&#39; options quantity (optional)
     * @param  string|null $display_value Defines the value that will be displayed for the option value (optional)
     * @param  bool|null $clear_cache Is cache clear required (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionValueUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productOptionValueUpdateAsyncWithHttpInfo($product_id, $option_id, $option_value_id, $option_value = null, $price = null, $quantity = null, $display_value = null, $clear_cache = true, string $contentType = self::contentTypes['productOptionValueUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AccountConfigUpdate200Response';
        $request = $this->productOptionValueUpdateRequest($product_id, $option_id, $option_value_id, $option_value, $price, $quantity, $display_value, $clear_cache, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productOptionValueUpdate'
     *
     * @param  string $product_id Defines product id where the option value should be updated (required)
     * @param  string $option_id Defines option id where the value has to be updated (required)
     * @param  string $option_value_id Defines value id that has to be assigned (required)
     * @param  string|null $option_value Defines option value that has to be added (optional)
     * @param  float|null $price Defines new product option price (optional)
     * @param  float|null $quantity Defines new products&#39; options quantity (optional)
     * @param  string|null $display_value Defines the value that will be displayed for the option value (optional)
     * @param  bool|null $clear_cache Is cache clear required (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productOptionValueUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productOptionValueUpdateRequest($product_id, $option_id, $option_value_id, $option_value = null, $price = null, $quantity = null, $display_value = null, $clear_cache = true, string $contentType = self::contentTypes['productOptionValueUpdate'][0])
    {

        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_id when calling productOptionValueUpdate'
            );
        }

        // verify the required parameter 'option_id' is set
        if ($option_id === null || (is_array($option_id) && count($option_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_id when calling productOptionValueUpdate'
            );
        }

        // verify the required parameter 'option_value_id' is set
        if ($option_value_id === null || (is_array($option_value_id) && count($option_value_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $option_value_id when calling productOptionValueUpdate'
            );
        }







        $resourcePath = '/product.option.value.update.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_id,
            'product_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $option_id,
            'option_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $option_value_id,
            'option_value_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $option_value,
            'option_value', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $price,
            'price', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quantity,
            'quantity', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $display_value,
            'display_value', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $clear_cache,
            'clear_cache', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productPriceAdd
     *
     * product.price.add
     *
     * @param  \OpenAPI\Client\Model\ProductPriceAdd $product_price_add product_price_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productPriceAdd'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CartValidate200Response
     */
    public function productPriceAdd($product_price_add, string $contentType = self::contentTypes['productPriceAdd'][0])
    {
        list($response) = $this->productPriceAddWithHttpInfo($product_price_add, $contentType);
        return $response;
    }

    /**
     * Operation productPriceAddWithHttpInfo
     *
     * product.price.add
     *
     * @param  \OpenAPI\Client\Model\ProductPriceAdd $product_price_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productPriceAdd'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CartValidate200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productPriceAddWithHttpInfo($product_price_add, string $contentType = self::contentTypes['productPriceAdd'][0])
    {
        $request = $this->productPriceAddRequest($product_price_add, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CartValidate200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CartValidate200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CartValidate200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\CartValidate200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CartValidate200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productPriceAddAsync
     *
     * product.price.add
     *
     * @param  \OpenAPI\Client\Model\ProductPriceAdd $product_price_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productPriceAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productPriceAddAsync($product_price_add, string $contentType = self::contentTypes['productPriceAdd'][0])
    {
        return $this->productPriceAddAsyncWithHttpInfo($product_price_add, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productPriceAddAsyncWithHttpInfo
     *
     * product.price.add
     *
     * @param  \OpenAPI\Client\Model\ProductPriceAdd $product_price_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productPriceAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productPriceAddAsyncWithHttpInfo($product_price_add, string $contentType = self::contentTypes['productPriceAdd'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CartValidate200Response';
        $request = $this->productPriceAddRequest($product_price_add, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productPriceAdd'
     *
     * @param  \OpenAPI\Client\Model\ProductPriceAdd $product_price_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productPriceAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productPriceAddRequest($product_price_add, string $contentType = self::contentTypes['productPriceAdd'][0])
    {

        // verify the required parameter 'product_price_add' is set
        if ($product_price_add === null || (is_array($product_price_add) && count($product_price_add) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_price_add when calling productPriceAdd'
            );
        }


        $resourcePath = '/product.price.add.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($product_price_add)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($product_price_add));
            } else {
                $httpBody = $product_price_add;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productPriceDelete
     *
     * product.price.delete
     *
     * @param  string $product_id Defines the product where the price has to be deleted (required)
     * @param  string|null $group_prices Defines product&#39;s group prices (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productPriceDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AttributeDelete200Response
     */
    public function productPriceDelete($product_id, $group_prices = null, $store_id = null, string $contentType = self::contentTypes['productPriceDelete'][0])
    {
        list($response) = $this->productPriceDeleteWithHttpInfo($product_id, $group_prices, $store_id, $contentType);
        return $response;
    }

    /**
     * Operation productPriceDeleteWithHttpInfo
     *
     * product.price.delete
     *
     * @param  string $product_id Defines the product where the price has to be deleted (required)
     * @param  string|null $group_prices Defines product&#39;s group prices (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productPriceDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AttributeDelete200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productPriceDeleteWithHttpInfo($product_id, $group_prices = null, $store_id = null, string $contentType = self::contentTypes['productPriceDelete'][0])
    {
        $request = $this->productPriceDeleteRequest($product_id, $group_prices, $store_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AttributeDelete200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\AttributeDelete200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AttributeDelete200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\AttributeDelete200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AttributeDelete200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productPriceDeleteAsync
     *
     * product.price.delete
     *
     * @param  string $product_id Defines the product where the price has to be deleted (required)
     * @param  string|null $group_prices Defines product&#39;s group prices (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productPriceDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productPriceDeleteAsync($product_id, $group_prices = null, $store_id = null, string $contentType = self::contentTypes['productPriceDelete'][0])
    {
        return $this->productPriceDeleteAsyncWithHttpInfo($product_id, $group_prices, $store_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productPriceDeleteAsyncWithHttpInfo
     *
     * product.price.delete
     *
     * @param  string $product_id Defines the product where the price has to be deleted (required)
     * @param  string|null $group_prices Defines product&#39;s group prices (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productPriceDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productPriceDeleteAsyncWithHttpInfo($product_id, $group_prices = null, $store_id = null, string $contentType = self::contentTypes['productPriceDelete'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AttributeDelete200Response';
        $request = $this->productPriceDeleteRequest($product_id, $group_prices, $store_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productPriceDelete'
     *
     * @param  string $product_id Defines the product where the price has to be deleted (required)
     * @param  string|null $group_prices Defines product&#39;s group prices (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productPriceDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productPriceDeleteRequest($product_id, $group_prices = null, $store_id = null, string $contentType = self::contentTypes['productPriceDelete'][0])
    {

        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_id when calling productPriceDelete'
            );
        }




        $resourcePath = '/product.price.delete.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_id,
            'product_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_prices,
            'group_prices', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $store_id,
            'store_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productPriceUpdate
     *
     * product.price.update
     *
     * @param  \OpenAPI\Client\Model\ProductPriceUpdate $product_price_update product_price_update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productPriceUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AccountConfigUpdate200Response
     */
    public function productPriceUpdate($product_price_update, string $contentType = self::contentTypes['productPriceUpdate'][0])
    {
        list($response) = $this->productPriceUpdateWithHttpInfo($product_price_update, $contentType);
        return $response;
    }

    /**
     * Operation productPriceUpdateWithHttpInfo
     *
     * product.price.update
     *
     * @param  \OpenAPI\Client\Model\ProductPriceUpdate $product_price_update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productPriceUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AccountConfigUpdate200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productPriceUpdateWithHttpInfo($product_price_update, string $contentType = self::contentTypes['productPriceUpdate'][0])
    {
        $request = $this->productPriceUpdateRequest($product_price_update, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AccountConfigUpdate200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\AccountConfigUpdate200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AccountConfigUpdate200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\AccountConfigUpdate200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AccountConfigUpdate200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productPriceUpdateAsync
     *
     * product.price.update
     *
     * @param  \OpenAPI\Client\Model\ProductPriceUpdate $product_price_update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productPriceUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productPriceUpdateAsync($product_price_update, string $contentType = self::contentTypes['productPriceUpdate'][0])
    {
        return $this->productPriceUpdateAsyncWithHttpInfo($product_price_update, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productPriceUpdateAsyncWithHttpInfo
     *
     * product.price.update
     *
     * @param  \OpenAPI\Client\Model\ProductPriceUpdate $product_price_update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productPriceUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productPriceUpdateAsyncWithHttpInfo($product_price_update, string $contentType = self::contentTypes['productPriceUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AccountConfigUpdate200Response';
        $request = $this->productPriceUpdateRequest($product_price_update, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productPriceUpdate'
     *
     * @param  \OpenAPI\Client\Model\ProductPriceUpdate $product_price_update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productPriceUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productPriceUpdateRequest($product_price_update, string $contentType = self::contentTypes['productPriceUpdate'][0])
    {

        // verify the required parameter 'product_price_update' is set
        if ($product_price_update === null || (is_array($product_price_update) && count($product_price_update) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_price_update when calling productPriceUpdate'
            );
        }


        $resourcePath = '/product.price.update.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($product_price_update)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($product_price_update));
            } else {
                $httpBody = $product_price_update;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productReviewList
     *
     * product.review.list
     *
     * @param  string $product_id Product id (required)
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  string|null $page_cursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $ids Retrieves reviews specified by ids (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string|null $status Defines status (optional)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,customer_id,email,message,status,product_id,nick_name,summary,rating,ratings,status,created_time')
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productReviewList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModelResponseProductReviewList
     */
    public function productReviewList($product_id, $start = 0, $page_cursor = null, $count = 10, $ids = null, $store_id = null, $status = null, $params = 'id,customer_id,email,message,status,product_id,nick_name,summary,rating,ratings,status,created_time', $exclude = null, $response_fields = null, string $contentType = self::contentTypes['productReviewList'][0])
    {
        list($response) = $this->productReviewListWithHttpInfo($product_id, $start, $page_cursor, $count, $ids, $store_id, $status, $params, $exclude, $response_fields, $contentType);
        return $response;
    }

    /**
     * Operation productReviewListWithHttpInfo
     *
     * product.review.list
     *
     * @param  string $product_id Product id (required)
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  string|null $page_cursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $ids Retrieves reviews specified by ids (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string|null $status Defines status (optional)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,customer_id,email,message,status,product_id,nick_name,summary,rating,ratings,status,created_time')
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productReviewList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModelResponseProductReviewList, HTTP status code, HTTP response headers (array of strings)
     */
    public function productReviewListWithHttpInfo($product_id, $start = 0, $page_cursor = null, $count = 10, $ids = null, $store_id = null, $status = null, $params = 'id,customer_id,email,message,status,product_id,nick_name,summary,rating,ratings,status,created_time', $exclude = null, $response_fields = null, string $contentType = self::contentTypes['productReviewList'][0])
    {
        $request = $this->productReviewListRequest($product_id, $start, $page_cursor, $count, $ids, $store_id, $status, $params, $exclude, $response_fields, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ModelResponseProductReviewList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ModelResponseProductReviewList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ModelResponseProductReviewList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ModelResponseProductReviewList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModelResponseProductReviewList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productReviewListAsync
     *
     * product.review.list
     *
     * @param  string $product_id Product id (required)
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  string|null $page_cursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $ids Retrieves reviews specified by ids (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string|null $status Defines status (optional)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,customer_id,email,message,status,product_id,nick_name,summary,rating,ratings,status,created_time')
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productReviewList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productReviewListAsync($product_id, $start = 0, $page_cursor = null, $count = 10, $ids = null, $store_id = null, $status = null, $params = 'id,customer_id,email,message,status,product_id,nick_name,summary,rating,ratings,status,created_time', $exclude = null, $response_fields = null, string $contentType = self::contentTypes['productReviewList'][0])
    {
        return $this->productReviewListAsyncWithHttpInfo($product_id, $start, $page_cursor, $count, $ids, $store_id, $status, $params, $exclude, $response_fields, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productReviewListAsyncWithHttpInfo
     *
     * product.review.list
     *
     * @param  string $product_id Product id (required)
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  string|null $page_cursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $ids Retrieves reviews specified by ids (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string|null $status Defines status (optional)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,customer_id,email,message,status,product_id,nick_name,summary,rating,ratings,status,created_time')
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productReviewList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productReviewListAsyncWithHttpInfo($product_id, $start = 0, $page_cursor = null, $count = 10, $ids = null, $store_id = null, $status = null, $params = 'id,customer_id,email,message,status,product_id,nick_name,summary,rating,ratings,status,created_time', $exclude = null, $response_fields = null, string $contentType = self::contentTypes['productReviewList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ModelResponseProductReviewList';
        $request = $this->productReviewListRequest($product_id, $start, $page_cursor, $count, $ids, $store_id, $status, $params, $exclude, $response_fields, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productReviewList'
     *
     * @param  string $product_id Product id (required)
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  string|null $page_cursor Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter) (optional)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $ids Retrieves reviews specified by ids (optional)
     * @param  string|null $store_id Store Id (optional)
     * @param  string|null $status Defines status (optional)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,customer_id,email,message,status,product_id,nick_name,summary,rating,ratings,status,created_time')
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $response_fields Set this parameter in order to choose which entity fields you want to retrieve (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productReviewList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productReviewListRequest($product_id, $start = 0, $page_cursor = null, $count = 10, $ids = null, $store_id = null, $status = null, $params = 'id,customer_id,email,message,status,product_id,nick_name,summary,rating,ratings,status,created_time', $exclude = null, $response_fields = null, string $contentType = self::contentTypes['productReviewList'][0])
    {

        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_id when calling productReviewList'
            );
        }











        $resourcePath = '/product.review.list.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_cursor,
            'page_cursor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_id,
            'product_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ids,
            'ids', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $store_id,
            'store_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $params,
            'params', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclude,
            'exclude', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $response_fields,
            'response_fields', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productStoreAssign
     *
     * product.store.assign
     *
     * @param  string $product_id Defines id of the product which should be assigned to a store (required)
     * @param  string $store_id Defines id of the store product should be assigned to (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productStoreAssign'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AccountConfigUpdate200Response
     */
    public function productStoreAssign($product_id, $store_id, string $contentType = self::contentTypes['productStoreAssign'][0])
    {
        list($response) = $this->productStoreAssignWithHttpInfo($product_id, $store_id, $contentType);
        return $response;
    }

    /**
     * Operation productStoreAssignWithHttpInfo
     *
     * product.store.assign
     *
     * @param  string $product_id Defines id of the product which should be assigned to a store (required)
     * @param  string $store_id Defines id of the store product should be assigned to (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productStoreAssign'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AccountConfigUpdate200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productStoreAssignWithHttpInfo($product_id, $store_id, string $contentType = self::contentTypes['productStoreAssign'][0])
    {
        $request = $this->productStoreAssignRequest($product_id, $store_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AccountConfigUpdate200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\AccountConfigUpdate200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AccountConfigUpdate200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\AccountConfigUpdate200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AccountConfigUpdate200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productStoreAssignAsync
     *
     * product.store.assign
     *
     * @param  string $product_id Defines id of the product which should be assigned to a store (required)
     * @param  string $store_id Defines id of the store product should be assigned to (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productStoreAssign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productStoreAssignAsync($product_id, $store_id, string $contentType = self::contentTypes['productStoreAssign'][0])
    {
        return $this->productStoreAssignAsyncWithHttpInfo($product_id, $store_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productStoreAssignAsyncWithHttpInfo
     *
     * product.store.assign
     *
     * @param  string $product_id Defines id of the product which should be assigned to a store (required)
     * @param  string $store_id Defines id of the store product should be assigned to (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productStoreAssign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productStoreAssignAsyncWithHttpInfo($product_id, $store_id, string $contentType = self::contentTypes['productStoreAssign'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AccountConfigUpdate200Response';
        $request = $this->productStoreAssignRequest($product_id, $store_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productStoreAssign'
     *
     * @param  string $product_id Defines id of the product which should be assigned to a store (required)
     * @param  string $store_id Defines id of the store product should be assigned to (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productStoreAssign'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productStoreAssignRequest($product_id, $store_id, string $contentType = self::contentTypes['productStoreAssign'][0])
    {

        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_id when calling productStoreAssign'
            );
        }

        // verify the required parameter 'store_id' is set
        if ($store_id === null || (is_array($store_id) && count($store_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_id when calling productStoreAssign'
            );
        }


        $resourcePath = '/product.store.assign.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_id,
            'product_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $store_id,
            'store_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productTaxAdd
     *
     * product.tax.add
     *
     * @param  \OpenAPI\Client\Model\ProductTaxAdd $product_tax_add product_tax_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productTaxAdd'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductTaxAdd200Response
     */
    public function productTaxAdd($product_tax_add, string $contentType = self::contentTypes['productTaxAdd'][0])
    {
        list($response) = $this->productTaxAddWithHttpInfo($product_tax_add, $contentType);
        return $response;
    }

    /**
     * Operation productTaxAddWithHttpInfo
     *
     * product.tax.add
     *
     * @param  \OpenAPI\Client\Model\ProductTaxAdd $product_tax_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productTaxAdd'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductTaxAdd200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productTaxAddWithHttpInfo($product_tax_add, string $contentType = self::contentTypes['productTaxAdd'][0])
    {
        $request = $this->productTaxAddRequest($product_tax_add, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProductTaxAdd200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProductTaxAdd200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProductTaxAdd200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ProductTaxAdd200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductTaxAdd200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productTaxAddAsync
     *
     * product.tax.add
     *
     * @param  \OpenAPI\Client\Model\ProductTaxAdd $product_tax_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productTaxAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productTaxAddAsync($product_tax_add, string $contentType = self::contentTypes['productTaxAdd'][0])
    {
        return $this->productTaxAddAsyncWithHttpInfo($product_tax_add, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productTaxAddAsyncWithHttpInfo
     *
     * product.tax.add
     *
     * @param  \OpenAPI\Client\Model\ProductTaxAdd $product_tax_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productTaxAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productTaxAddAsyncWithHttpInfo($product_tax_add, string $contentType = self::contentTypes['productTaxAdd'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProductTaxAdd200Response';
        $request = $this->productTaxAddRequest($product_tax_add, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productTaxAdd'
     *
     * @param  \OpenAPI\Client\Model\ProductTaxAdd $product_tax_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productTaxAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productTaxAddRequest($product_tax_add, string $contentType = self::contentTypes['productTaxAdd'][0])
    {

        // verify the required parameter 'product_tax_add' is set
        if ($product_tax_add === null || (is_array($product_tax_add) && count($product_tax_add) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_tax_add when calling productTaxAdd'
            );
        }


        $resourcePath = '/product.tax.add.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($product_tax_add)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($product_tax_add));
            } else {
                $httpBody = $product_tax_add;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productUpdate
     *
     * product.update
     *
     * @param  \OpenAPI\Client\Model\ProductUpdate $product_update product_update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AccountConfigUpdate200Response
     */
    public function productUpdate($product_update, string $contentType = self::contentTypes['productUpdate'][0])
    {
        list($response) = $this->productUpdateWithHttpInfo($product_update, $contentType);
        return $response;
    }

    /**
     * Operation productUpdateWithHttpInfo
     *
     * product.update
     *
     * @param  \OpenAPI\Client\Model\ProductUpdate $product_update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AccountConfigUpdate200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productUpdateWithHttpInfo($product_update, string $contentType = self::contentTypes['productUpdate'][0])
    {
        $request = $this->productUpdateRequest($product_update, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AccountConfigUpdate200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\AccountConfigUpdate200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AccountConfigUpdate200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\AccountConfigUpdate200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AccountConfigUpdate200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productUpdateAsync
     *
     * product.update
     *
     * @param  \OpenAPI\Client\Model\ProductUpdate $product_update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productUpdateAsync($product_update, string $contentType = self::contentTypes['productUpdate'][0])
    {
        return $this->productUpdateAsyncWithHttpInfo($product_update, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productUpdateAsyncWithHttpInfo
     *
     * product.update
     *
     * @param  \OpenAPI\Client\Model\ProductUpdate $product_update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productUpdateAsyncWithHttpInfo($product_update, string $contentType = self::contentTypes['productUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AccountConfigUpdate200Response';
        $request = $this->productUpdateRequest($product_update, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productUpdate'
     *
     * @param  \OpenAPI\Client\Model\ProductUpdate $product_update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productUpdateRequest($product_update, string $contentType = self::contentTypes['productUpdate'][0])
    {

        // verify the required parameter 'product_update' is set
        if ($product_update === null || (is_array($product_update) && count($product_update) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_update when calling productUpdate'
            );
        }


        $resourcePath = '/product.update.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($product_update)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($product_update));
            } else {
                $httpBody = $product_update;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productUpdateBatch
     *
     * product.update.batch
     *
     * @param  \OpenAPI\Client\Model\ProductUpdateBatch $product_update_batch product_update_batch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productUpdateBatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CategoryAddBatch200Response
     */
    public function productUpdateBatch($product_update_batch, string $contentType = self::contentTypes['productUpdateBatch'][0])
    {
        list($response) = $this->productUpdateBatchWithHttpInfo($product_update_batch, $contentType);
        return $response;
    }

    /**
     * Operation productUpdateBatchWithHttpInfo
     *
     * product.update.batch
     *
     * @param  \OpenAPI\Client\Model\ProductUpdateBatch $product_update_batch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productUpdateBatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CategoryAddBatch200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productUpdateBatchWithHttpInfo($product_update_batch, string $contentType = self::contentTypes['productUpdateBatch'][0])
    {
        $request = $this->productUpdateBatchRequest($product_update_batch, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CategoryAddBatch200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CategoryAddBatch200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CategoryAddBatch200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\CategoryAddBatch200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CategoryAddBatch200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productUpdateBatchAsync
     *
     * product.update.batch
     *
     * @param  \OpenAPI\Client\Model\ProductUpdateBatch $product_update_batch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productUpdateBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productUpdateBatchAsync($product_update_batch, string $contentType = self::contentTypes['productUpdateBatch'][0])
    {
        return $this->productUpdateBatchAsyncWithHttpInfo($product_update_batch, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productUpdateBatchAsyncWithHttpInfo
     *
     * product.update.batch
     *
     * @param  \OpenAPI\Client\Model\ProductUpdateBatch $product_update_batch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productUpdateBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productUpdateBatchAsyncWithHttpInfo($product_update_batch, string $contentType = self::contentTypes['productUpdateBatch'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CategoryAddBatch200Response';
        $request = $this->productUpdateBatchRequest($product_update_batch, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productUpdateBatch'
     *
     * @param  \OpenAPI\Client\Model\ProductUpdateBatch $product_update_batch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productUpdateBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productUpdateBatchRequest($product_update_batch, string $contentType = self::contentTypes['productUpdateBatch'][0])
    {

        // verify the required parameter 'product_update_batch' is set
        if ($product_update_batch === null || (is_array($product_update_batch) && count($product_update_batch) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_update_batch when calling productUpdateBatch'
            );
        }


        $resourcePath = '/product.update.batch.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($product_update_batch)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($product_update_batch));
            } else {
                $httpBody = $product_update_batch;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productVariantAdd
     *
     * product.variant.add
     *
     * @param  \OpenAPI\Client\Model\ProductVariantAdd $product_variant_add product_variant_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantAdd'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductVariantAdd200Response
     */
    public function productVariantAdd($product_variant_add, string $contentType = self::contentTypes['productVariantAdd'][0])
    {
        list($response) = $this->productVariantAddWithHttpInfo($product_variant_add, $contentType);
        return $response;
    }

    /**
     * Operation productVariantAddWithHttpInfo
     *
     * product.variant.add
     *
     * @param  \OpenAPI\Client\Model\ProductVariantAdd $product_variant_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantAdd'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductVariantAdd200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productVariantAddWithHttpInfo($product_variant_add, string $contentType = self::contentTypes['productVariantAdd'][0])
    {
        $request = $this->productVariantAddRequest($product_variant_add, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProductVariantAdd200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProductVariantAdd200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProductVariantAdd200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ProductVariantAdd200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductVariantAdd200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productVariantAddAsync
     *
     * product.variant.add
     *
     * @param  \OpenAPI\Client\Model\ProductVariantAdd $product_variant_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productVariantAddAsync($product_variant_add, string $contentType = self::contentTypes['productVariantAdd'][0])
    {
        return $this->productVariantAddAsyncWithHttpInfo($product_variant_add, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productVariantAddAsyncWithHttpInfo
     *
     * product.variant.add
     *
     * @param  \OpenAPI\Client\Model\ProductVariantAdd $product_variant_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productVariantAddAsyncWithHttpInfo($product_variant_add, string $contentType = self::contentTypes['productVariantAdd'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProductVariantAdd200Response';
        $request = $this->productVariantAddRequest($product_variant_add, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productVariantAdd'
     *
     * @param  \OpenAPI\Client\Model\ProductVariantAdd $product_variant_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productVariantAddRequest($product_variant_add, string $contentType = self::contentTypes['productVariantAdd'][0])
    {

        // verify the required parameter 'product_variant_add' is set
        if ($product_variant_add === null || (is_array($product_variant_add) && count($product_variant_add) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_variant_add when calling productVariantAdd'
            );
        }


        $resourcePath = '/product.variant.add.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($product_variant_add)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($product_variant_add));
            } else {
                $httpBody = $product_variant_add;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productVariantAddBatch
     *
     * product.variant.add.batch
     *
     * @param  \OpenAPI\Client\Model\ProductVariantAddBatch $product_variant_add_batch product_variant_add_batch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantAddBatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CategoryAddBatch200Response
     */
    public function productVariantAddBatch($product_variant_add_batch, string $contentType = self::contentTypes['productVariantAddBatch'][0])
    {
        list($response) = $this->productVariantAddBatchWithHttpInfo($product_variant_add_batch, $contentType);
        return $response;
    }

    /**
     * Operation productVariantAddBatchWithHttpInfo
     *
     * product.variant.add.batch
     *
     * @param  \OpenAPI\Client\Model\ProductVariantAddBatch $product_variant_add_batch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantAddBatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CategoryAddBatch200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productVariantAddBatchWithHttpInfo($product_variant_add_batch, string $contentType = self::contentTypes['productVariantAddBatch'][0])
    {
        $request = $this->productVariantAddBatchRequest($product_variant_add_batch, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CategoryAddBatch200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CategoryAddBatch200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CategoryAddBatch200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\CategoryAddBatch200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CategoryAddBatch200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productVariantAddBatchAsync
     *
     * product.variant.add.batch
     *
     * @param  \OpenAPI\Client\Model\ProductVariantAddBatch $product_variant_add_batch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantAddBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productVariantAddBatchAsync($product_variant_add_batch, string $contentType = self::contentTypes['productVariantAddBatch'][0])
    {
        return $this->productVariantAddBatchAsyncWithHttpInfo($product_variant_add_batch, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productVariantAddBatchAsyncWithHttpInfo
     *
     * product.variant.add.batch
     *
     * @param  \OpenAPI\Client\Model\ProductVariantAddBatch $product_variant_add_batch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantAddBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productVariantAddBatchAsyncWithHttpInfo($product_variant_add_batch, string $contentType = self::contentTypes['productVariantAddBatch'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CategoryAddBatch200Response';
        $request = $this->productVariantAddBatchRequest($product_variant_add_batch, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productVariantAddBatch'
     *
     * @param  \OpenAPI\Client\Model\ProductVariantAddBatch $product_variant_add_batch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantAddBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productVariantAddBatchRequest($product_variant_add_batch, string $contentType = self::contentTypes['productVariantAddBatch'][0])
    {

        // verify the required parameter 'product_variant_add_batch' is set
        if ($product_variant_add_batch === null || (is_array($product_variant_add_batch) && count($product_variant_add_batch) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_variant_add_batch when calling productVariantAddBatch'
            );
        }


        $resourcePath = '/product.variant.add.batch.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($product_variant_add_batch)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($product_variant_add_batch));
            } else {
                $httpBody = $product_variant_add_batch;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productVariantCount
     *
     * product.variant.count
     *
     * @param  string $product_id Retrieves products&#39; variants specified by product id (required)
     * @param  string|null $created_from Retrieve entities from their creation date (optional)
     * @param  string|null $created_to Retrieve entities to their creation date (optional)
     * @param  string|null $modified_from Retrieve entities from their modification date (optional)
     * @param  string|null $modified_to Retrieve entities to their modification date (optional)
     * @param  string|null $category_id Counts products variants specified by category id (optional)
     * @param  string|null $store_id Retrieves variants specified by store id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantCount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductVariantCount200Response
     * @deprecated
     */
    public function productVariantCount($product_id, $created_from = null, $created_to = null, $modified_from = null, $modified_to = null, $category_id = null, $store_id = null, string $contentType = self::contentTypes['productVariantCount'][0])
    {
        list($response) = $this->productVariantCountWithHttpInfo($product_id, $created_from, $created_to, $modified_from, $modified_to, $category_id, $store_id, $contentType);
        return $response;
    }

    /**
     * Operation productVariantCountWithHttpInfo
     *
     * product.variant.count
     *
     * @param  string $product_id Retrieves products&#39; variants specified by product id (required)
     * @param  string|null $created_from Retrieve entities from their creation date (optional)
     * @param  string|null $created_to Retrieve entities to their creation date (optional)
     * @param  string|null $modified_from Retrieve entities from their modification date (optional)
     * @param  string|null $modified_to Retrieve entities to their modification date (optional)
     * @param  string|null $category_id Counts products variants specified by category id (optional)
     * @param  string|null $store_id Retrieves variants specified by store id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantCount'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductVariantCount200Response, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function productVariantCountWithHttpInfo($product_id, $created_from = null, $created_to = null, $modified_from = null, $modified_to = null, $category_id = null, $store_id = null, string $contentType = self::contentTypes['productVariantCount'][0])
    {
        $request = $this->productVariantCountRequest($product_id, $created_from, $created_to, $modified_from, $modified_to, $category_id, $store_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProductVariantCount200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProductVariantCount200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProductVariantCount200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ProductVariantCount200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductVariantCount200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productVariantCountAsync
     *
     * product.variant.count
     *
     * @param  string $product_id Retrieves products&#39; variants specified by product id (required)
     * @param  string|null $created_from Retrieve entities from their creation date (optional)
     * @param  string|null $created_to Retrieve entities to their creation date (optional)
     * @param  string|null $modified_from Retrieve entities from their modification date (optional)
     * @param  string|null $modified_to Retrieve entities to their modification date (optional)
     * @param  string|null $category_id Counts products variants specified by category id (optional)
     * @param  string|null $store_id Retrieves variants specified by store id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function productVariantCountAsync($product_id, $created_from = null, $created_to = null, $modified_from = null, $modified_to = null, $category_id = null, $store_id = null, string $contentType = self::contentTypes['productVariantCount'][0])
    {
        return $this->productVariantCountAsyncWithHttpInfo($product_id, $created_from, $created_to, $modified_from, $modified_to, $category_id, $store_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productVariantCountAsyncWithHttpInfo
     *
     * product.variant.count
     *
     * @param  string $product_id Retrieves products&#39; variants specified by product id (required)
     * @param  string|null $created_from Retrieve entities from their creation date (optional)
     * @param  string|null $created_to Retrieve entities to their creation date (optional)
     * @param  string|null $modified_from Retrieve entities from their modification date (optional)
     * @param  string|null $modified_to Retrieve entities to their modification date (optional)
     * @param  string|null $category_id Counts products variants specified by category id (optional)
     * @param  string|null $store_id Retrieves variants specified by store id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function productVariantCountAsyncWithHttpInfo($product_id, $created_from = null, $created_to = null, $modified_from = null, $modified_to = null, $category_id = null, $store_id = null, string $contentType = self::contentTypes['productVariantCount'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProductVariantCount200Response';
        $request = $this->productVariantCountRequest($product_id, $created_from, $created_to, $modified_from, $modified_to, $category_id, $store_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productVariantCount'
     *
     * @param  string $product_id Retrieves products&#39; variants specified by product id (required)
     * @param  string|null $created_from Retrieve entities from their creation date (optional)
     * @param  string|null $created_to Retrieve entities to their creation date (optional)
     * @param  string|null $modified_from Retrieve entities from their modification date (optional)
     * @param  string|null $modified_to Retrieve entities to their modification date (optional)
     * @param  string|null $category_id Counts products variants specified by category id (optional)
     * @param  string|null $store_id Retrieves variants specified by store id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function productVariantCountRequest($product_id, $created_from = null, $created_to = null, $modified_from = null, $modified_to = null, $category_id = null, $store_id = null, string $contentType = self::contentTypes['productVariantCount'][0])
    {

        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_id when calling productVariantCount'
            );
        }








        $resourcePath = '/product.variant.count.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_from,
            'created_from', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_to,
            'created_to', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_from,
            'modified_from', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_to,
            'modified_to', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category_id,
            'category_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_id,
            'product_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $store_id,
            'store_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productVariantDelete
     *
     * product.variant.delete
     *
     * @param  string $id Defines variant removal, specified by variant id (required)
     * @param  string $product_id Defines product&#39;s id where the variant has to be deleted (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AttributeValueDelete200Response
     */
    public function productVariantDelete($id, $product_id, $store_id = null, string $contentType = self::contentTypes['productVariantDelete'][0])
    {
        list($response) = $this->productVariantDeleteWithHttpInfo($id, $product_id, $store_id, $contentType);
        return $response;
    }

    /**
     * Operation productVariantDeleteWithHttpInfo
     *
     * product.variant.delete
     *
     * @param  string $id Defines variant removal, specified by variant id (required)
     * @param  string $product_id Defines product&#39;s id where the variant has to be deleted (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AttributeValueDelete200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productVariantDeleteWithHttpInfo($id, $product_id, $store_id = null, string $contentType = self::contentTypes['productVariantDelete'][0])
    {
        $request = $this->productVariantDeleteRequest($id, $product_id, $store_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AttributeValueDelete200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\AttributeValueDelete200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AttributeValueDelete200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\AttributeValueDelete200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AttributeValueDelete200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productVariantDeleteAsync
     *
     * product.variant.delete
     *
     * @param  string $id Defines variant removal, specified by variant id (required)
     * @param  string $product_id Defines product&#39;s id where the variant has to be deleted (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productVariantDeleteAsync($id, $product_id, $store_id = null, string $contentType = self::contentTypes['productVariantDelete'][0])
    {
        return $this->productVariantDeleteAsyncWithHttpInfo($id, $product_id, $store_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productVariantDeleteAsyncWithHttpInfo
     *
     * product.variant.delete
     *
     * @param  string $id Defines variant removal, specified by variant id (required)
     * @param  string $product_id Defines product&#39;s id where the variant has to be deleted (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productVariantDeleteAsyncWithHttpInfo($id, $product_id, $store_id = null, string $contentType = self::contentTypes['productVariantDelete'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AttributeValueDelete200Response';
        $request = $this->productVariantDeleteRequest($id, $product_id, $store_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productVariantDelete'
     *
     * @param  string $id Defines variant removal, specified by variant id (required)
     * @param  string $product_id Defines product&#39;s id where the variant has to be deleted (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productVariantDeleteRequest($id, $product_id, $store_id = null, string $contentType = self::contentTypes['productVariantDelete'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productVariantDelete'
            );
        }

        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_id when calling productVariantDelete'
            );
        }



        $resourcePath = '/product.variant.delete.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_id,
            'product_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $store_id,
            'store_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productVariantDeleteBatch
     *
     * product.variant.delete.batch
     *
     * @param  \OpenAPI\Client\Model\ProductVariantDeleteBatch $product_variant_delete_batch product_variant_delete_batch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantDeleteBatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CategoryAddBatch200Response
     */
    public function productVariantDeleteBatch($product_variant_delete_batch, string $contentType = self::contentTypes['productVariantDeleteBatch'][0])
    {
        list($response) = $this->productVariantDeleteBatchWithHttpInfo($product_variant_delete_batch, $contentType);
        return $response;
    }

    /**
     * Operation productVariantDeleteBatchWithHttpInfo
     *
     * product.variant.delete.batch
     *
     * @param  \OpenAPI\Client\Model\ProductVariantDeleteBatch $product_variant_delete_batch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantDeleteBatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CategoryAddBatch200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productVariantDeleteBatchWithHttpInfo($product_variant_delete_batch, string $contentType = self::contentTypes['productVariantDeleteBatch'][0])
    {
        $request = $this->productVariantDeleteBatchRequest($product_variant_delete_batch, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CategoryAddBatch200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CategoryAddBatch200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CategoryAddBatch200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\CategoryAddBatch200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CategoryAddBatch200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productVariantDeleteBatchAsync
     *
     * product.variant.delete.batch
     *
     * @param  \OpenAPI\Client\Model\ProductVariantDeleteBatch $product_variant_delete_batch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantDeleteBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productVariantDeleteBatchAsync($product_variant_delete_batch, string $contentType = self::contentTypes['productVariantDeleteBatch'][0])
    {
        return $this->productVariantDeleteBatchAsyncWithHttpInfo($product_variant_delete_batch, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productVariantDeleteBatchAsyncWithHttpInfo
     *
     * product.variant.delete.batch
     *
     * @param  \OpenAPI\Client\Model\ProductVariantDeleteBatch $product_variant_delete_batch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantDeleteBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productVariantDeleteBatchAsyncWithHttpInfo($product_variant_delete_batch, string $contentType = self::contentTypes['productVariantDeleteBatch'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CategoryAddBatch200Response';
        $request = $this->productVariantDeleteBatchRequest($product_variant_delete_batch, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productVariantDeleteBatch'
     *
     * @param  \OpenAPI\Client\Model\ProductVariantDeleteBatch $product_variant_delete_batch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantDeleteBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productVariantDeleteBatchRequest($product_variant_delete_batch, string $contentType = self::contentTypes['productVariantDeleteBatch'][0])
    {

        // verify the required parameter 'product_variant_delete_batch' is set
        if ($product_variant_delete_batch === null || (is_array($product_variant_delete_batch) && count($product_variant_delete_batch) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_variant_delete_batch when calling productVariantDeleteBatch'
            );
        }


        $resourcePath = '/product.variant.delete.batch.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($product_variant_delete_batch)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($product_variant_delete_batch));
            } else {
                $httpBody = $product_variant_delete_batch;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productVariantImageAdd
     *
     * product.variant.image.add
     *
     * @param  \OpenAPI\Client\Model\ProductVariantImageAdd $product_variant_image_add product_variant_image_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantImageAdd'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductVariantImageAdd200Response
     */
    public function productVariantImageAdd($product_variant_image_add, string $contentType = self::contentTypes['productVariantImageAdd'][0])
    {
        list($response) = $this->productVariantImageAddWithHttpInfo($product_variant_image_add, $contentType);
        return $response;
    }

    /**
     * Operation productVariantImageAddWithHttpInfo
     *
     * product.variant.image.add
     *
     * @param  \OpenAPI\Client\Model\ProductVariantImageAdd $product_variant_image_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantImageAdd'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductVariantImageAdd200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productVariantImageAddWithHttpInfo($product_variant_image_add, string $contentType = self::contentTypes['productVariantImageAdd'][0])
    {
        $request = $this->productVariantImageAddRequest($product_variant_image_add, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProductVariantImageAdd200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProductVariantImageAdd200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProductVariantImageAdd200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ProductVariantImageAdd200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductVariantImageAdd200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productVariantImageAddAsync
     *
     * product.variant.image.add
     *
     * @param  \OpenAPI\Client\Model\ProductVariantImageAdd $product_variant_image_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantImageAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productVariantImageAddAsync($product_variant_image_add, string $contentType = self::contentTypes['productVariantImageAdd'][0])
    {
        return $this->productVariantImageAddAsyncWithHttpInfo($product_variant_image_add, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productVariantImageAddAsyncWithHttpInfo
     *
     * product.variant.image.add
     *
     * @param  \OpenAPI\Client\Model\ProductVariantImageAdd $product_variant_image_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantImageAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productVariantImageAddAsyncWithHttpInfo($product_variant_image_add, string $contentType = self::contentTypes['productVariantImageAdd'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProductVariantImageAdd200Response';
        $request = $this->productVariantImageAddRequest($product_variant_image_add, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productVariantImageAdd'
     *
     * @param  \OpenAPI\Client\Model\ProductVariantImageAdd $product_variant_image_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantImageAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productVariantImageAddRequest($product_variant_image_add, string $contentType = self::contentTypes['productVariantImageAdd'][0])
    {

        // verify the required parameter 'product_variant_image_add' is set
        if ($product_variant_image_add === null || (is_array($product_variant_image_add) && count($product_variant_image_add) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_variant_image_add when calling productVariantImageAdd'
            );
        }


        $resourcePath = '/product.variant.image.add.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($product_variant_image_add)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($product_variant_image_add));
            } else {
                $httpBody = $product_variant_image_add;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productVariantImageDelete
     *
     * product.variant.image.delete
     *
     * @param  string $product_id Defines product id where the variant image should be deleted (required)
     * @param  string $product_variant_id Defines product&#39;s variants specified by variant id (required)
     * @param  string $id Entity id (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantImageDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AttributeDelete200Response
     */
    public function productVariantImageDelete($product_id, $product_variant_id, $id, $store_id = null, string $contentType = self::contentTypes['productVariantImageDelete'][0])
    {
        list($response) = $this->productVariantImageDeleteWithHttpInfo($product_id, $product_variant_id, $id, $store_id, $contentType);
        return $response;
    }

    /**
     * Operation productVariantImageDeleteWithHttpInfo
     *
     * product.variant.image.delete
     *
     * @param  string $product_id Defines product id where the variant image should be deleted (required)
     * @param  string $product_variant_id Defines product&#39;s variants specified by variant id (required)
     * @param  string $id Entity id (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantImageDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AttributeDelete200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productVariantImageDeleteWithHttpInfo($product_id, $product_variant_id, $id, $store_id = null, string $contentType = self::contentTypes['productVariantImageDelete'][0])
    {
        $request = $this->productVariantImageDeleteRequest($product_id, $product_variant_id, $id, $store_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AttributeDelete200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\AttributeDelete200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AttributeDelete200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\AttributeDelete200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AttributeDelete200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productVariantImageDeleteAsync
     *
     * product.variant.image.delete
     *
     * @param  string $product_id Defines product id where the variant image should be deleted (required)
     * @param  string $product_variant_id Defines product&#39;s variants specified by variant id (required)
     * @param  string $id Entity id (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantImageDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productVariantImageDeleteAsync($product_id, $product_variant_id, $id, $store_id = null, string $contentType = self::contentTypes['productVariantImageDelete'][0])
    {
        return $this->productVariantImageDeleteAsyncWithHttpInfo($product_id, $product_variant_id, $id, $store_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productVariantImageDeleteAsyncWithHttpInfo
     *
     * product.variant.image.delete
     *
     * @param  string $product_id Defines product id where the variant image should be deleted (required)
     * @param  string $product_variant_id Defines product&#39;s variants specified by variant id (required)
     * @param  string $id Entity id (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantImageDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productVariantImageDeleteAsyncWithHttpInfo($product_id, $product_variant_id, $id, $store_id = null, string $contentType = self::contentTypes['productVariantImageDelete'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AttributeDelete200Response';
        $request = $this->productVariantImageDeleteRequest($product_id, $product_variant_id, $id, $store_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productVariantImageDelete'
     *
     * @param  string $product_id Defines product id where the variant image should be deleted (required)
     * @param  string $product_variant_id Defines product&#39;s variants specified by variant id (required)
     * @param  string $id Entity id (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantImageDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productVariantImageDeleteRequest($product_id, $product_variant_id, $id, $store_id = null, string $contentType = self::contentTypes['productVariantImageDelete'][0])
    {

        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_id when calling productVariantImageDelete'
            );
        }

        // verify the required parameter 'product_variant_id' is set
        if ($product_variant_id === null || (is_array($product_variant_id) && count($product_variant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_variant_id when calling productVariantImageDelete'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productVariantImageDelete'
            );
        }



        $resourcePath = '/product.variant.image.delete.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_id,
            'product_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_variant_id,
            'product_variant_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $store_id,
            'store_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productVariantInfo
     *
     * product.variant.info
     *
     * @param  string $id Retrieves variant&#39;s info specified by variant id (required)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,name,description,price')
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $store_id Retrieves variant info specified by store id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantInfo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductInfo200Response
     * @deprecated
     */
    public function productVariantInfo($id, $params = 'id,name,description,price', $exclude = null, $store_id = null, string $contentType = self::contentTypes['productVariantInfo'][0])
    {
        list($response) = $this->productVariantInfoWithHttpInfo($id, $params, $exclude, $store_id, $contentType);
        return $response;
    }

    /**
     * Operation productVariantInfoWithHttpInfo
     *
     * product.variant.info
     *
     * @param  string $id Retrieves variant&#39;s info specified by variant id (required)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,name,description,price')
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $store_id Retrieves variant info specified by store id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantInfo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductInfo200Response, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function productVariantInfoWithHttpInfo($id, $params = 'id,name,description,price', $exclude = null, $store_id = null, string $contentType = self::contentTypes['productVariantInfo'][0])
    {
        $request = $this->productVariantInfoRequest($id, $params, $exclude, $store_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProductInfo200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProductInfo200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProductInfo200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ProductInfo200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductInfo200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productVariantInfoAsync
     *
     * product.variant.info
     *
     * @param  string $id Retrieves variant&#39;s info specified by variant id (required)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,name,description,price')
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $store_id Retrieves variant info specified by store id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function productVariantInfoAsync($id, $params = 'id,name,description,price', $exclude = null, $store_id = null, string $contentType = self::contentTypes['productVariantInfo'][0])
    {
        return $this->productVariantInfoAsyncWithHttpInfo($id, $params, $exclude, $store_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productVariantInfoAsyncWithHttpInfo
     *
     * product.variant.info
     *
     * @param  string $id Retrieves variant&#39;s info specified by variant id (required)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,name,description,price')
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $store_id Retrieves variant info specified by store id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function productVariantInfoAsyncWithHttpInfo($id, $params = 'id,name,description,price', $exclude = null, $store_id = null, string $contentType = self::contentTypes['productVariantInfo'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProductInfo200Response';
        $request = $this->productVariantInfoRequest($id, $params, $exclude, $store_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productVariantInfo'
     *
     * @param  string $id Retrieves variant&#39;s info specified by variant id (required)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,name,description,price')
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $store_id Retrieves variant info specified by store id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function productVariantInfoRequest($id, $params = 'id,name,description,price', $exclude = null, $store_id = null, string $contentType = self::contentTypes['productVariantInfo'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productVariantInfo'
            );
        }





        $resourcePath = '/product.variant.info.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $params,
            'params', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclude,
            'exclude', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $store_id,
            'store_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productVariantList
     *
     * product.variant.list
     *
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,name,description,price')
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $created_from Retrieve entities from their creation date (optional)
     * @param  string|null $created_to Retrieve entities to their creation date (optional)
     * @param  string|null $modified_from Retrieve entities from their modification date (optional)
     * @param  string|null $modified_to Retrieve entities to their modification date (optional)
     * @param  string|null $category_id Retrieves products variants specified by category id (optional)
     * @param  string|null $product_id Retrieves products&#39; variants specified by product id (optional)
     * @param  string|null $store_id Retrieves variants specified by store id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProductVariantList200Response
     * @deprecated
     */
    public function productVariantList($start = 0, $count = 10, $params = 'id,name,description,price', $exclude = null, $created_from = null, $created_to = null, $modified_from = null, $modified_to = null, $category_id = null, $product_id = null, $store_id = null, string $contentType = self::contentTypes['productVariantList'][0])
    {
        list($response) = $this->productVariantListWithHttpInfo($start, $count, $params, $exclude, $created_from, $created_to, $modified_from, $modified_to, $category_id, $product_id, $store_id, $contentType);
        return $response;
    }

    /**
     * Operation productVariantListWithHttpInfo
     *
     * product.variant.list
     *
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,name,description,price')
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $created_from Retrieve entities from their creation date (optional)
     * @param  string|null $created_to Retrieve entities to their creation date (optional)
     * @param  string|null $modified_from Retrieve entities from their modification date (optional)
     * @param  string|null $modified_to Retrieve entities to their modification date (optional)
     * @param  string|null $category_id Retrieves products variants specified by category id (optional)
     * @param  string|null $product_id Retrieves products&#39; variants specified by product id (optional)
     * @param  string|null $store_id Retrieves variants specified by store id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProductVariantList200Response, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function productVariantListWithHttpInfo($start = 0, $count = 10, $params = 'id,name,description,price', $exclude = null, $created_from = null, $created_to = null, $modified_from = null, $modified_to = null, $category_id = null, $product_id = null, $store_id = null, string $contentType = self::contentTypes['productVariantList'][0])
    {
        $request = $this->productVariantListRequest($start, $count, $params, $exclude, $created_from, $created_to, $modified_from, $modified_to, $category_id, $product_id, $store_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProductVariantList200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProductVariantList200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProductVariantList200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ProductVariantList200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProductVariantList200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productVariantListAsync
     *
     * product.variant.list
     *
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,name,description,price')
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $created_from Retrieve entities from their creation date (optional)
     * @param  string|null $created_to Retrieve entities to their creation date (optional)
     * @param  string|null $modified_from Retrieve entities from their modification date (optional)
     * @param  string|null $modified_to Retrieve entities to their modification date (optional)
     * @param  string|null $category_id Retrieves products variants specified by category id (optional)
     * @param  string|null $product_id Retrieves products&#39; variants specified by product id (optional)
     * @param  string|null $store_id Retrieves variants specified by store id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function productVariantListAsync($start = 0, $count = 10, $params = 'id,name,description,price', $exclude = null, $created_from = null, $created_to = null, $modified_from = null, $modified_to = null, $category_id = null, $product_id = null, $store_id = null, string $contentType = self::contentTypes['productVariantList'][0])
    {
        return $this->productVariantListAsyncWithHttpInfo($start, $count, $params, $exclude, $created_from, $created_to, $modified_from, $modified_to, $category_id, $product_id, $store_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productVariantListAsyncWithHttpInfo
     *
     * product.variant.list
     *
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,name,description,price')
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $created_from Retrieve entities from their creation date (optional)
     * @param  string|null $created_to Retrieve entities to their creation date (optional)
     * @param  string|null $modified_from Retrieve entities from their modification date (optional)
     * @param  string|null $modified_to Retrieve entities to their modification date (optional)
     * @param  string|null $category_id Retrieves products variants specified by category id (optional)
     * @param  string|null $product_id Retrieves products&#39; variants specified by product id (optional)
     * @param  string|null $store_id Retrieves variants specified by store id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function productVariantListAsyncWithHttpInfo($start = 0, $count = 10, $params = 'id,name,description,price', $exclude = null, $created_from = null, $created_to = null, $modified_from = null, $modified_to = null, $category_id = null, $product_id = null, $store_id = null, string $contentType = self::contentTypes['productVariantList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProductVariantList200Response';
        $request = $this->productVariantListRequest($start, $count, $params, $exclude, $created_from, $created_to, $modified_from, $modified_to, $category_id, $product_id, $store_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productVariantList'
     *
     * @param  int|null $start This parameter sets the number from which you want to get entities (optional, default to 0)
     * @param  int|null $count This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250 (optional, default to 10)
     * @param  string|null $params Set this parameter in order to choose which entity fields you want to retrieve (optional, default to 'id,name,description,price')
     * @param  string|null $exclude Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all (optional)
     * @param  string|null $created_from Retrieve entities from their creation date (optional)
     * @param  string|null $created_to Retrieve entities to their creation date (optional)
     * @param  string|null $modified_from Retrieve entities from their modification date (optional)
     * @param  string|null $modified_to Retrieve entities to their modification date (optional)
     * @param  string|null $category_id Retrieves products variants specified by category id (optional)
     * @param  string|null $product_id Retrieves products&#39; variants specified by product id (optional)
     * @param  string|null $store_id Retrieves variants specified by store id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function productVariantListRequest($start = 0, $count = 10, $params = 'id,name,description,price', $exclude = null, $created_from = null, $created_to = null, $modified_from = null, $modified_to = null, $category_id = null, $product_id = null, $store_id = null, string $contentType = self::contentTypes['productVariantList'][0])
    {













        $resourcePath = '/product.variant.list.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $params,
            'params', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclude,
            'exclude', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_from,
            'created_from', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_to,
            'created_to', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_from,
            'modified_from', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $modified_to,
            'modified_to', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $category_id,
            'category_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_id,
            'product_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $store_id,
            'store_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productVariantPriceAdd
     *
     * product.variant.price.add
     *
     * @param  \OpenAPI\Client\Model\ProductVariantPriceAdd $product_variant_price_add product_variant_price_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantPriceAdd'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CartValidate200Response
     */
    public function productVariantPriceAdd($product_variant_price_add, string $contentType = self::contentTypes['productVariantPriceAdd'][0])
    {
        list($response) = $this->productVariantPriceAddWithHttpInfo($product_variant_price_add, $contentType);
        return $response;
    }

    /**
     * Operation productVariantPriceAddWithHttpInfo
     *
     * product.variant.price.add
     *
     * @param  \OpenAPI\Client\Model\ProductVariantPriceAdd $product_variant_price_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantPriceAdd'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CartValidate200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productVariantPriceAddWithHttpInfo($product_variant_price_add, string $contentType = self::contentTypes['productVariantPriceAdd'][0])
    {
        $request = $this->productVariantPriceAddRequest($product_variant_price_add, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CartValidate200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CartValidate200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CartValidate200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\CartValidate200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CartValidate200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productVariantPriceAddAsync
     *
     * product.variant.price.add
     *
     * @param  \OpenAPI\Client\Model\ProductVariantPriceAdd $product_variant_price_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantPriceAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productVariantPriceAddAsync($product_variant_price_add, string $contentType = self::contentTypes['productVariantPriceAdd'][0])
    {
        return $this->productVariantPriceAddAsyncWithHttpInfo($product_variant_price_add, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productVariantPriceAddAsyncWithHttpInfo
     *
     * product.variant.price.add
     *
     * @param  \OpenAPI\Client\Model\ProductVariantPriceAdd $product_variant_price_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantPriceAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productVariantPriceAddAsyncWithHttpInfo($product_variant_price_add, string $contentType = self::contentTypes['productVariantPriceAdd'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CartValidate200Response';
        $request = $this->productVariantPriceAddRequest($product_variant_price_add, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productVariantPriceAdd'
     *
     * @param  \OpenAPI\Client\Model\ProductVariantPriceAdd $product_variant_price_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantPriceAdd'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productVariantPriceAddRequest($product_variant_price_add, string $contentType = self::contentTypes['productVariantPriceAdd'][0])
    {

        // verify the required parameter 'product_variant_price_add' is set
        if ($product_variant_price_add === null || (is_array($product_variant_price_add) && count($product_variant_price_add) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_variant_price_add when calling productVariantPriceAdd'
            );
        }


        $resourcePath = '/product.variant.price.add.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($product_variant_price_add)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($product_variant_price_add));
            } else {
                $httpBody = $product_variant_price_add;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productVariantPriceDelete
     *
     * product.variant.price.delete
     *
     * @param  string $id Defines the variant where the price has to be deleted (required)
     * @param  string $product_id Product id (required)
     * @param  string $group_prices Defines variants&#39;s group prices (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantPriceDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AttributeDelete200Response
     */
    public function productVariantPriceDelete($id, $product_id, $group_prices, $store_id = null, string $contentType = self::contentTypes['productVariantPriceDelete'][0])
    {
        list($response) = $this->productVariantPriceDeleteWithHttpInfo($id, $product_id, $group_prices, $store_id, $contentType);
        return $response;
    }

    /**
     * Operation productVariantPriceDeleteWithHttpInfo
     *
     * product.variant.price.delete
     *
     * @param  string $id Defines the variant where the price has to be deleted (required)
     * @param  string $product_id Product id (required)
     * @param  string $group_prices Defines variants&#39;s group prices (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantPriceDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AttributeDelete200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productVariantPriceDeleteWithHttpInfo($id, $product_id, $group_prices, $store_id = null, string $contentType = self::contentTypes['productVariantPriceDelete'][0])
    {
        $request = $this->productVariantPriceDeleteRequest($id, $product_id, $group_prices, $store_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AttributeDelete200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\AttributeDelete200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AttributeDelete200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\AttributeDelete200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AttributeDelete200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productVariantPriceDeleteAsync
     *
     * product.variant.price.delete
     *
     * @param  string $id Defines the variant where the price has to be deleted (required)
     * @param  string $product_id Product id (required)
     * @param  string $group_prices Defines variants&#39;s group prices (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantPriceDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productVariantPriceDeleteAsync($id, $product_id, $group_prices, $store_id = null, string $contentType = self::contentTypes['productVariantPriceDelete'][0])
    {
        return $this->productVariantPriceDeleteAsyncWithHttpInfo($id, $product_id, $group_prices, $store_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productVariantPriceDeleteAsyncWithHttpInfo
     *
     * product.variant.price.delete
     *
     * @param  string $id Defines the variant where the price has to be deleted (required)
     * @param  string $product_id Product id (required)
     * @param  string $group_prices Defines variants&#39;s group prices (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantPriceDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productVariantPriceDeleteAsyncWithHttpInfo($id, $product_id, $group_prices, $store_id = null, string $contentType = self::contentTypes['productVariantPriceDelete'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AttributeDelete200Response';
        $request = $this->productVariantPriceDeleteRequest($id, $product_id, $group_prices, $store_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productVariantPriceDelete'
     *
     * @param  string $id Defines the variant where the price has to be deleted (required)
     * @param  string $product_id Product id (required)
     * @param  string $group_prices Defines variants&#39;s group prices (required)
     * @param  string|null $store_id Store Id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantPriceDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productVariantPriceDeleteRequest($id, $product_id, $group_prices, $store_id = null, string $contentType = self::contentTypes['productVariantPriceDelete'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productVariantPriceDelete'
            );
        }

        // verify the required parameter 'product_id' is set
        if ($product_id === null || (is_array($product_id) && count($product_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_id when calling productVariantPriceDelete'
            );
        }

        // verify the required parameter 'group_prices' is set
        if ($group_prices === null || (is_array($group_prices) && count($group_prices) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_prices when calling productVariantPriceDelete'
            );
        }



        $resourcePath = '/product.variant.price.delete.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_id,
            'product_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $group_prices,
            'group_prices', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $store_id,
            'store_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productVariantPriceUpdate
     *
     * product.variant.price.update
     *
     * @param  \OpenAPI\Client\Model\ProductVariantPriceUpdate $product_variant_price_update product_variant_price_update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantPriceUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AccountConfigUpdate200Response
     */
    public function productVariantPriceUpdate($product_variant_price_update, string $contentType = self::contentTypes['productVariantPriceUpdate'][0])
    {
        list($response) = $this->productVariantPriceUpdateWithHttpInfo($product_variant_price_update, $contentType);
        return $response;
    }

    /**
     * Operation productVariantPriceUpdateWithHttpInfo
     *
     * product.variant.price.update
     *
     * @param  \OpenAPI\Client\Model\ProductVariantPriceUpdate $product_variant_price_update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantPriceUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AccountConfigUpdate200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productVariantPriceUpdateWithHttpInfo($product_variant_price_update, string $contentType = self::contentTypes['productVariantPriceUpdate'][0])
    {
        $request = $this->productVariantPriceUpdateRequest($product_variant_price_update, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AccountConfigUpdate200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\AccountConfigUpdate200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AccountConfigUpdate200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\AccountConfigUpdate200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AccountConfigUpdate200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productVariantPriceUpdateAsync
     *
     * product.variant.price.update
     *
     * @param  \OpenAPI\Client\Model\ProductVariantPriceUpdate $product_variant_price_update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantPriceUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productVariantPriceUpdateAsync($product_variant_price_update, string $contentType = self::contentTypes['productVariantPriceUpdate'][0])
    {
        return $this->productVariantPriceUpdateAsyncWithHttpInfo($product_variant_price_update, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productVariantPriceUpdateAsyncWithHttpInfo
     *
     * product.variant.price.update
     *
     * @param  \OpenAPI\Client\Model\ProductVariantPriceUpdate $product_variant_price_update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantPriceUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productVariantPriceUpdateAsyncWithHttpInfo($product_variant_price_update, string $contentType = self::contentTypes['productVariantPriceUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AccountConfigUpdate200Response';
        $request = $this->productVariantPriceUpdateRequest($product_variant_price_update, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productVariantPriceUpdate'
     *
     * @param  \OpenAPI\Client\Model\ProductVariantPriceUpdate $product_variant_price_update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantPriceUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productVariantPriceUpdateRequest($product_variant_price_update, string $contentType = self::contentTypes['productVariantPriceUpdate'][0])
    {

        // verify the required parameter 'product_variant_price_update' is set
        if ($product_variant_price_update === null || (is_array($product_variant_price_update) && count($product_variant_price_update) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_variant_price_update when calling productVariantPriceUpdate'
            );
        }


        $resourcePath = '/product.variant.price.update.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($product_variant_price_update)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($product_variant_price_update));
            } else {
                $httpBody = $product_variant_price_update;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productVariantUpdate
     *
     * product.variant.update
     *
     * @param  \OpenAPI\Client\Model\ProductVariantUpdate $product_variant_update product_variant_update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AccountConfigUpdate200Response
     */
    public function productVariantUpdate($product_variant_update, string $contentType = self::contentTypes['productVariantUpdate'][0])
    {
        list($response) = $this->productVariantUpdateWithHttpInfo($product_variant_update, $contentType);
        return $response;
    }

    /**
     * Operation productVariantUpdateWithHttpInfo
     *
     * product.variant.update
     *
     * @param  \OpenAPI\Client\Model\ProductVariantUpdate $product_variant_update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantUpdate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AccountConfigUpdate200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productVariantUpdateWithHttpInfo($product_variant_update, string $contentType = self::contentTypes['productVariantUpdate'][0])
    {
        $request = $this->productVariantUpdateRequest($product_variant_update, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AccountConfigUpdate200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\AccountConfigUpdate200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AccountConfigUpdate200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\AccountConfigUpdate200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AccountConfigUpdate200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productVariantUpdateAsync
     *
     * product.variant.update
     *
     * @param  \OpenAPI\Client\Model\ProductVariantUpdate $product_variant_update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productVariantUpdateAsync($product_variant_update, string $contentType = self::contentTypes['productVariantUpdate'][0])
    {
        return $this->productVariantUpdateAsyncWithHttpInfo($product_variant_update, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productVariantUpdateAsyncWithHttpInfo
     *
     * product.variant.update
     *
     * @param  \OpenAPI\Client\Model\ProductVariantUpdate $product_variant_update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productVariantUpdateAsyncWithHttpInfo($product_variant_update, string $contentType = self::contentTypes['productVariantUpdate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AccountConfigUpdate200Response';
        $request = $this->productVariantUpdateRequest($product_variant_update, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productVariantUpdate'
     *
     * @param  \OpenAPI\Client\Model\ProductVariantUpdate $product_variant_update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productVariantUpdateRequest($product_variant_update, string $contentType = self::contentTypes['productVariantUpdate'][0])
    {

        // verify the required parameter 'product_variant_update' is set
        if ($product_variant_update === null || (is_array($product_variant_update) && count($product_variant_update) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_variant_update when calling productVariantUpdate'
            );
        }


        $resourcePath = '/product.variant.update.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($product_variant_update)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($product_variant_update));
            } else {
                $httpBody = $product_variant_update;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productVariantUpdateBatch
     *
     * product.variant.update.batch
     *
     * @param  \OpenAPI\Client\Model\ProductVariantUpdateBatch $product_variant_update_batch product_variant_update_batch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantUpdateBatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CategoryAddBatch200Response
     */
    public function productVariantUpdateBatch($product_variant_update_batch, string $contentType = self::contentTypes['productVariantUpdateBatch'][0])
    {
        list($response) = $this->productVariantUpdateBatchWithHttpInfo($product_variant_update_batch, $contentType);
        return $response;
    }

    /**
     * Operation productVariantUpdateBatchWithHttpInfo
     *
     * product.variant.update.batch
     *
     * @param  \OpenAPI\Client\Model\ProductVariantUpdateBatch $product_variant_update_batch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantUpdateBatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CategoryAddBatch200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function productVariantUpdateBatchWithHttpInfo($product_variant_update_batch, string $contentType = self::contentTypes['productVariantUpdateBatch'][0])
    {
        $request = $this->productVariantUpdateBatchRequest($product_variant_update_batch, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CategoryAddBatch200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CategoryAddBatch200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CategoryAddBatch200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\CategoryAddBatch200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CategoryAddBatch200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productVariantUpdateBatchAsync
     *
     * product.variant.update.batch
     *
     * @param  \OpenAPI\Client\Model\ProductVariantUpdateBatch $product_variant_update_batch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantUpdateBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productVariantUpdateBatchAsync($product_variant_update_batch, string $contentType = self::contentTypes['productVariantUpdateBatch'][0])
    {
        return $this->productVariantUpdateBatchAsyncWithHttpInfo($product_variant_update_batch, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productVariantUpdateBatchAsyncWithHttpInfo
     *
     * product.variant.update.batch
     *
     * @param  \OpenAPI\Client\Model\ProductVariantUpdateBatch $product_variant_update_batch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantUpdateBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productVariantUpdateBatchAsyncWithHttpInfo($product_variant_update_batch, string $contentType = self::contentTypes['productVariantUpdateBatch'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CategoryAddBatch200Response';
        $request = $this->productVariantUpdateBatchRequest($product_variant_update_batch, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productVariantUpdateBatch'
     *
     * @param  \OpenAPI\Client\Model\ProductVariantUpdateBatch $product_variant_update_batch (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productVariantUpdateBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productVariantUpdateBatchRequest($product_variant_update_batch, string $contentType = self::contentTypes['productVariantUpdateBatch'][0])
    {

        // verify the required parameter 'product_variant_update_batch' is set
        if ($product_variant_update_batch === null || (is_array($product_variant_update_batch) && count($product_variant_update_batch) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_variant_update_batch when calling productVariantUpdateBatch'
            );
        }


        $resourcePath = '/product.variant.update.batch.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($product_variant_update_batch)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($product_variant_update_batch));
            } else {
                $httpBody = $product_variant_update_batch;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-store-key');
        if ($apiKey !== null) {
            $headers['x-store-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
